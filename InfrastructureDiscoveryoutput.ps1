<#
.SYNOPSIS
    Aggregates previously discovered environment data into a user-centric relational
    model. Processes users in batches and supports resuming from the last completed batch.

.DESCRIPTION
    This script reads CSV files generated by a data discovery script.
    It processes users in batches, appending results to output CSVs incrementally.
    It saves progress to a state file, allowing the script to resume from the last
    successfully processed user if interrupted.
    It uses pre-discovered data for shared mailbox permissions and skips Graph sections on failure.
    Includes the custom Get-Gplink function and enhanced Graph connection handling.
    The output is a set of related CSV files saved to the OutputCsvPath.

.PARAMETER InputCsvPath
    The directory containing the discovery CSV files. Defaults to 'C:\DiscoveryData'.

.PARAMETER OutputCsvPath
    The mandatory directory where the aggregated CSV files will be saved.

.PARAMETER ClientId
    The Azure AD application Client ID for service principal authentication.

.PARAMETER ClientSecret
    The Azure AD application Client Secret for service principal authentication.

.PARAMETER TenantId
    The Azure AD Tenant ID for authentication.

.PARAMETER UserIdentifierProperty
    Property from ADUsers CSV for unique user ID ('UserPrincipalName' or 'SamAccountName'). Defaults to 'UserPrincipalName'.

.PARAMETER DomainController
    Domain controller for AD/GPO queries. Defaults to 'ad.zedra.com'.

.PARAMETER BatchSize
    Number of users to process before writing to output files and saving state. Defaults to 100.

.EXAMPLE
    .\Aggregate-UserCentricData_Resumable.ps1 -OutputCsvPath "C:\UserCentricOutput" -ClientId "0d16d2c2-2bf4-40f2-b4ef-20ba8dfbb7a2" -ClientSecret "your-secret" -TenantId "c405117b-3153-4ed8-8c65-b3475764ab8f"

.NOTES
    Author: Your Name/Org (Modified with community function)
    Date: 2025-05-08
    Version: 2.10.11 (Service Principal Auth)
             - Updated to use service principal authentication for Microsoft Graph to match discovery script
             - Added ClientId, ClientSecret, TenantId parameters
             - Updated Connect-GraphAggregator to use ClientSecretCredential
             - Adjusted column names and GPO processing to align with discovery script output
             - Removed interactive prompts for module installation
    Version: 2.10.10 (Interactive Auth)
             - Reverted to interactive user authentication for Microsoft Graph
    Version: 2.10.9 (Resumable - Fixed Finally block)
             - Wrapped main processing logic in a try block so the finally block executes correctly.
    Version: 2.10.8 (Resumable - Fixed OU Hierarchy)
             - Corrected OU hierarchy construction logic in Get-AppliedGPOsForUser to prevent DN duplication.
    Version: 2.10.7 (Resumable - Fixed AddRange cast)
             - Explicitly cast input array to [PSCustomObject[]] before calling AddRange to fix type conversion error.
    Version: 2.10.6 (Resumable - Fixed initialization)
             - Fixed "Cannot find an overload for 'new'" error during list initialization in resume logic.
    Version: 2.10.5 (Resumable)
             - Added batch processing and resume capability using a state file.
             - Replaced all '-f' string formatting in Write-Log calls with '$()' subexpressions.
             - Removed live EXO lookup for Shared Mailbox Perms, uses input CSV.
             - Added logic to skip Graph lookups on connection failure and report at end.
             - Includes custom Get-Gplink function & enhanced Graph connection handling.

    CRITICAL: Requires RSAT: Group Policy Management Tools feature installed.
    Requires discovery CSVs in InputCsvPath.
    Requires appropriate permissions for AD, GPO, and Microsoft Graph.
#>
param(
    [Parameter(Mandatory=$false)]
    [string]$InputCsvPath = "C:\DiscoveryData",

    [Parameter(Mandatory=$true)]
    [string]$OutputCsvPath,

    [Parameter(Mandatory=$true)]
    [string]$ClientId,

    [Parameter(Mandatory=$true)]
    [string]$ClientSecret,

    [Parameter(Mandatory=$true)]
    [string]$TenantId,

    [Parameter(Mandatory=$false)]
    [ValidateSet('UserPrincipalName', 'SamAccountName')]
    [string]$UserIdentifierProperty = 'UserPrincipalName',

    [Parameter(Mandatory=$false)]
    [string]$DomainController = "ad.zedra.com",

    [Parameter(Mandatory=$false)]
    [int]$BatchSize = 100
)

#region Global Settings & Setup
$ErrorActionPreference = "Stop"
$VerbosePreference = "Continue"

$script:GraphConnectionFailed = $false
$script:StateFilePath = Join-Path $OutputCsvPath "aggregation_progress.state"

function Write-Log {
    param(
        [Parameter(Mandatory=$true)]
        [string]$Message,
        [Parameter(Mandatory=$false)]
        [ValidateSet("INFO", "WARN", "ERROR")]
        [string]$Level = "INFO"
    )
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $cleanedMessage = $Message -replace "[\r\n]+", " "
    $LogMessage = "[$timestamp] [$Level] $cleanedMessage"
    switch ($Level) {
        "INFO" { Write-Host $LogMessage -ForegroundColor Green }
        "WARN" { Write-Host $LogMessage -ForegroundColor Yellow }
        "ERROR" { Write-Host $LogMessage -ForegroundColor Red }
    }
    Write-Verbose $LogMessage
    if ($script:LogPath -and (Test-Path $script:LogDir -PathType Container)) {
        try {
            Add-Content -Path $script:LogPath -Value $LogMessage -Encoding UTF8 -ErrorAction Stop
        } catch {
            Write-Warning "Failed to write to log file '$($script:LogPath)': $($_.Exception.Message)"
        }
    }
}

$script:requiredModules = @(
    @{ Name = "ActiveDirectory"; Version = $null; Installable = $false; Notes = "Requires RSAT: AD DS Tools feature." },
    @{ Name = "GroupPolicy"; Version = $null; Installable = $false; Notes = "Requires RSAT: Group Policy Management feature." },
    @{ Name = "Microsoft.Graph"; Version = $null; Installable = $true; Notes = "Needed for Intune/App Assignment lookups." },
    @{ Name = "Microsoft.Graph.Groups"; Version = $null; Installable = $true; Notes = "Needed for Group Membership resolution." },
    @{ Name = "Microsoft.Graph.Users"; Version = $null; Installable = $true; Notes = "Needed for User lookups." },
    @{ Name = "Microsoft.Graph.Applications"; Version = $null; Installable = $true; Notes = "Needed for App/SP lookups." },
    @{ Name = "Microsoft.Graph.DeviceManagement"; Version = $null; Installable = $true; Notes = "Needed for Intune Assignment lookups." }
)

$script:graphScopes = @(
    "Directory.Read.All", "GroupMember.Read.All", "User.Read.All", "Policy.Read.All",
    "DeviceManagementConfiguration.Read.All", "AppRoleAssignment.Read.All", "Application.Read.All"
)

$script:LogDir = Join-Path $OutputCsvPath "Logs"
$script:LogPath = Join-Path $script:LogDir "AggregationRun_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"

if (-not (Test-Path $OutputCsvPath -PathType Container)) {
    Write-Verbose "Creating output directory: $OutputCsvPath"
    try {
        New-Item -Path $OutputCsvPath -ItemType Directory -Force -ErrorAction Stop | Out-Null
    } catch {
        Write-Error "Failed to create output directory '$OutputCsvPath'. Error: $($_.Exception.Message)"; exit 1
    }
}

if (-not (Test-Path $script:LogDir -PathType Container)) {
    Write-Verbose "Creating log directory: $($script:LogDir)"
    try {
        New-Item -Path $script:LogDir -ItemType Directory -Force -ErrorAction Stop | Out-Null
    } catch {
        Write-Warning "Failed to create log directory '$($script:LogDir)'. Logging to file disabled."
        $script:LogPath = $null
    }
}

if ([string]::IsNullOrWhiteSpace($DomainController)) {
    Write-Log "ERROR: Domain Controller name is missing or invalid." -Level ERROR; exit 1
}
Write-Log "Using Domain Controller: $($DomainController)" -Level INFO
Write-Log "Batch Size: $($BatchSize)" -Level INFO
Write-Log "State File: $($script:StateFilePath)" -Level INFO

#endregion Global Settings & Setup

#region Core Functions
function Check-RequiredModules {
    Write-Log "Checking required PowerShell modules for aggregation..."
    $missingModules = @()

    foreach ($moduleInfo in $script:requiredModules) {
        $moduleName = $moduleInfo.Name
        $requiredVersion = $moduleInfo.Version
        $isInstallable = $moduleInfo.Installable
        $notes = $moduleInfo.Notes
        Write-Verbose "Checking for module: $moduleName"

        $installedModule = Get-Module -Name $moduleName -ListAvailable
        if (-not $installedModule) {
            Write-Verbose "Module $moduleName not found."
            $missingModules += $moduleInfo
        } elseif ($requiredVersion) {
            $versionMatch = $installedModule | Where-Object { $_.Version -eq $requiredVersion }
            if (-not $versionMatch) {
                Write-Verbose "Module $($moduleName) found, but required version $($requiredVersion) not installed. Found: $($installedModule.Version -join ', ')"
                $missingModules += $moduleInfo
            }
        } else {
            Write-Verbose "Module $($moduleName) found (any version acceptable)."
        }
    }

    if ($missingModules.Count -gt 0) {
        Write-Log "Missing required modules:" -Level "WARN"
        $nonInstallableMissing = @()

        foreach ($missing in $missingModules) {
            $versionInfo = if ($missing.Version) { "version $($missing.Version)" } else { "" }
            if ($missing.Installable) {
                Write-Log "ERROR: Installable module $($missing.Name) $($versionInfo) is missing. Please install manually." -Level ERROR
                $nonInstallableMissing += $missing
            } else {
                Write-Log "- $($missing.Name) $($versionInfo) (Not Installable via PSGallery. $($missing.Notes))" -Level WARN
                $nonInstallableMissing += $missing
            }
        }

        if ($nonInstallableMissing.Count -gt 0) {
            Write-Log "Cannot proceed without missing modules. Please ensure RSAT features or required modules are installed." -Level ERROR
            exit 1
        }
    } else {
        Write-Log "All required modules are available."
    }
}

function Connect-GraphAggregator {
    Write-Log "Checking Microsoft Graph connection for aggregation tasks..."
    $forceReconnect = $false

    try {
        $graphContext = Get-MgContext -ErrorAction SilentlyContinue
        if ($graphContext -and $graphContext.Account) {
            Write-Log "Existing Graph connection found for ClientId $($graphContext.ClientId)."
            $tokenScopes = $graphContext.Scopes -split ' '
            $missingScopes = $script:graphScopes | Where-Object { $_ -notin $tokenScopes }
            if ($missingScopes) {
                Write-Log "Current Graph connection missing required scopes: $($missingScopes -join ', ')" -Level WARN
                $forceReconnect = $true
            } else {
                try {
                    Get-MgContext -ErrorAction Stop | Out-Null
                    Write-Log "Existing Graph token appears valid."
                    return $true
                } catch {
                    Write-Log "Existing Graph token failed validity test: $($_.Exception.Message)" -Level WARN
                    $forceReconnect = $true
                }
            }
        } else {
            Write-Log "No existing Graph connection found."
            $forceReconnect = $true
        }
    } catch {
        Write-Log "Error checking existing Graph context: $($_.Exception.Message)" -Level WARN
        $forceReconnect = $true
    }

    if ($forceReconnect) {
        Write-Log "Attempting to disconnect any previous context and reconnect..."
        Disconnect-MgGraph -ErrorAction SilentlyContinue
        Write-Log "Connecting to Microsoft Graph using client credentials..."
        try {
            $secureSecret = ConvertTo-SecureString $ClientSecret -AsPlainText -Force
            $clientSecretCredential = New-Object System.Management.Automation.PSCredential ($ClientId, $secureSecret)
            Connect-MgGraph -ClientSecretCredential $clientSecretCredential -TenantId $TenantId -ErrorAction Stop
            $newContext = Get-MgContext -ErrorAction Stop
            Write-Log "Successfully connected to Microsoft Graph with ClientId $($newContext.ClientId)."
            return $true
        } catch {
            Write-Log "Graph connection failed: $($_.Exception.Message)" -Level ERROR
            return $false
        }
    }
    return $true
}

function Ensure-AggregatorConnections {
    Write-Log "Ensuring connections (Graph only check)..."
    if (-not (Connect-GraphAggregator)) {
        Write-Log "Graph connection failed. Graph-dependent data will be skipped." -Level WARN
        $script:GraphConnectionFailed = $true
    } else {
        Write-Log "Graph connection successful or already established." -Level INFO
        $script:GraphConnectionFailed = $false
    }
}

function Import-InputCsv {
    param(
        [Parameter(Mandatory=$true)]
        [string]$FileName
    )
    $filePath = Join-Path $InputCsvPath "$($FileName).csv"
    if (Test-Path $filePath -PathType Leaf) {
        Write-Log "Loading input file: $($filePath)"
        try {
            return Import-Csv -Path $filePath -Encoding UTF8 -ErrorAction Stop
        } catch {
            Write-Log "Error loading CSV '$($filePath)': $($_.Exception.Message)" -Level "ERROR"
            return $null
        }
    } else {
        Write-Log "Input file not found: '$($filePath)'" -Level "WARN"
        return $null
    }
}

function Append-BatchToCsvs {
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$BatchData
    )
    Write-Log "Appending batch data to CSV files..." -Level INFO
    foreach ($item in $BatchData.GetEnumerator()) {
        $fileNameBase = $item.Name
        $dataList = $item.Value
        $filePath = Join-Path $OutputCsvPath "$($fileNameBase).csv"
        if ($dataList -and $dataList.Count -gt 0) {
            try {
                $fileExists = Test-Path $filePath -PathType Leaf
                if (-not $fileExists) {
                    Write-Verbose "Creating and writing batch to $($filePath) (with headers)"
                    $dataList | Export-Csv -Path $filePath -NoTypeInformation -Encoding UTF8 -ErrorAction Stop
                } else {
                    Write-Verbose "Appending batch to $($filePath) (without headers)"
                    $dataList | Export-Csv -Path $filePath -NoTypeInformation -Encoding UTF8 -Append -ErrorAction Stop
                }
            } catch {
                Write-Log "Error writing batch to CSV '$($filePath)': $($_.Exception.Message)" -Level ERROR
            }
        }
    }
    Write-Log "Finished appending batch data." -Level INFO
}

function Get-Gplink {
    [cmdletBinding()]
    param (
        [string]$path,
        [string]$server,
        [string]$site
    )
    $configpart = (Get-ADRootDSE -ErrorAction SilentlyContinue).configurationNamingContext
    if (-not $configpart) {
        Write-Log "Get-Gplink: Could not get Configuration Naming Context from RootDSE." -Level WARN
        return $null
    }
    $gplinkObject = $null
    $target = $null
    try {
        if ($site) {
            $gplinkObject = Get-ADObject -Filter { distinguishedname -eq $site } -SearchBase $configpart -Properties gplink -Server $server -ErrorAction Stop
            $target = $site
        } elseif ($path) {
            $gplinkObject = Get-ADObject -Filter { distinguishedname -eq $path } -Properties gplink -Server $server -ErrorAction Stop
            $target = $path
        }
    } catch {
        Write-Log "Get-Gplink: Error getting AD object '$($path)$($site)' on server '$server': $($_.Exception.Message)" -Level WARN
        return $null
    }
    if ($gplinkObject -eq $null -or -not $gplinkObject.PSObject.Properties['gplink']) {
        return $null
    }
    if ($gplinkObject.gplink -and $gplinkObject.gplink.Trim().Length -gt 0) {
        $linkOrder = 0
        $results = [System.Collections.Generic.List[PSCustomObject]]::new()
        $splitLinks = $gplinkObject.gplink.split("]")
        for ($s = $splitLinks.count - 1; $s -gt -1; $s--) {
            if ($splitLinks[$s].length -gt 0) {
                $linkOrder++
                $gpoGuid = $null
                $domainName = $null
                try {
                    $linkData = $splitLinks[$s].TrimStart('[')
                    $parts = $linkData -split ';'
                    $ldapPath = $parts[0]
                    $options = $parts[1]
                    if ($ldapPath -like 'LDAP://*') {
                        $dnPart = $ldapPath -replace 'LDAP://CN=\{', '' -replace '\},CN=Policies,CN=System,', ''
                        if ($dnPart -match '^([0-9A-F]{8}-([0-9A-F]{4}-){3}[0-9A-F]{12})(.*)$') {
                            $gpoGuid = $Matches[1]
                            $domainDN = $Matches[3].TrimStart(',')
                            $domainName = $domainDN.replace("DC=", "").replace(",", ".")
                        } else {
                            Write-Log "Get-Gplink: Could not extract GUID from link: $($ldapPath)" -Level WARN
                            continue
                        }
                    } else {
                        Write-Log "Get-Gplink: Unexpected format in link: $($ldapPath)" -Level WARN
                        continue
                    }
                    $isEnabled = "No"
                    $isEnforced = "No"
                    if ($options -eq '0') { $isEnabled = "Yes"; $isEnforced = "No" }
                    elseif ($options -eq '1') { $isEnabled = "No"; $isEnforced = "No" }
                    elseif ($options -eq '2') { $isEnabled = "Yes"; $isEnforced = "Yes" }
                    elseif ($options -eq '3') { $isEnabled = "No"; $isEnforced = "Yes" }
                    $gpoDisplayName = "Orphaned GPLink"
                    $checkDC = $null
                    if ($domainName) {
                        $checkDC = (Get-ADDomainController -DomainName $domainName -Discover -ErrorAction SilentlyContinue).Name
                    }
                    if ($checkDC -and (Get-Command Get-GPO -ErrorAction SilentlyContinue)) {
                        $mygpo = Get-GPO -Guid $gpoGuid -Domain $domainName -Server $checkDC -ErrorAction SilentlyContinue
                        if ($mygpo) { $gpoDisplayName = $mygpo.DisplayName }
                    }
                    $returnObject = [PSCustomObject]@{
                        Target      = $target
                        GPOID       = $gpoGuid
                        DisplayName = $gpoDisplayName
                        Domain      = $domainName
                        Enforced    = $isEnforced
                        Enabled     = $isEnabled
                        Order       = $linkOrder
                    }
                    $results.Add($returnObject)
                } catch {
                    Write-Log "Get-Gplink: Error parsing link '$($splitLinks[$s])': $($_.Exception.Message)" -Level WARN
                    continue
                }
            }
        }
        return $results
    }
    return $null
}

function Get-AppliedGPOsForUser {
    param(
        [Parameter(Mandatory = $true)] [PSCustomObject]$User,
        [Parameter(Mandatory = $true)] [hashtable]$UserGroupMembershipSids,
        [Parameter(Mandatory = $true)] [hashtable]$GpoPermissionsCache,
        [Parameter(Mandatory = $true)] [hashtable]$GpoLinkCache
    )
    $appliedGpos = [System.Collections.Generic.List[PSCustomObject]]::new()
    $userSid = $User.SID
    if (-not $userSid -or -not ($userSid -is [string]) -or $userSid.Length -lt 5) {
        Write-Log "Cannot determine GPO application for $($User.$UserIdentifierProperty) without a valid user SID string." -Level WARN
        return $appliedGpos
    }
    $userGroupsSids = if ($UserGroupMembershipSids.ContainsKey($User.SamAccountName)) { $UserGroupMembershipSids[$User.SamAccountName] } else { @() }
    $ouPath = $User.DistinguishedName -replace '^CN=.*?,(OU=.*)$', '$1' -replace '^CN=.*?,(CN=(Users|Computers).*)$', '$1'
    $ouHierarchy = @()
    $currentOu = $ouPath
    $domainDN = if ($User.DistinguishedName -match 'DC=.*') { ($User.DistinguishedName -split '(DC=.*)', 2)[1] } else { $null }
    if (-not $domainDN) {
        Write-Log "Could not determine domain DN from user DN: $($User.DistinguishedName)" -Level WARN
        return $appliedGpos
    }
    while ($currentOu -ne $domainDN -and $currentOu -match '(OU=|CN=)') {
        $ouHierarchy += $currentOu
        $parentOu = $currentOu -replace '^(OU|CN)=.*?,(.*)$', '$2'
        if ($parentOu -eq $currentOu -or -not $parentOu) { break }
        $currentOu = $parentOu
    }
    $ouHierarchy += $domainDN
    $ouHierarchy = $ouHierarchy | Select-Object -Unique
    $processedGpoIds = [System.Collections.Generic.HashSet[string]]::new([System.StringComparer]::OrdinalIgnoreCase)
    foreach ($ouDN in $ouHierarchy) {
        try {
            if (-not $gpoLinkCache.ContainsKey($ouDN)) {
                Write-Verbose "Querying GPO links for OU/Domain: $($ouDN)"
                if ([string]::IsNullOrWhiteSpace($DomainController)) { throw "Domain Controller name is missing" }
                $gpoLinkCache[$ouDN] = Get-Gplink -path $ouDN -server $DomainController
            }
            $links = $gpoLinkCache[$ouDN]
            if ($links -ne $null -and $links.Count -gt 0) {
                foreach ($link in $links) {
                    $gpoId = $link.GPOID
                    if (-not $gpoId -or $gpoId.Length -ne 36) {
                        Write-Log "Skipping link on '$($ouDN)' due to invalid GPOID: '$($gpoId)'" -Level WARN
                        continue
                    }
                    $gpoName = $link.DisplayName
                    $isEnforced = ($link.Enforced -eq 'Yes')
                    $isEnabled = ($link.Enabled -eq 'Yes')
                    if (-not $isEnabled) {
                        Write-Verbose "Skipping disabled GPO link: $($gpoName) on $ouDN"
                        continue
                    }
                    if ($processedGpoIds.Contains($gpoId) -and !$isEnforced) {
                        Write-Verbose "Skipping GPO '$($gpoName)' linked at '$($ouDN)' as it was already processed."
                        continue
                    }
                    if (-not $GpoPermissionsCache.ContainsKey($gpoId)) {
                        Write-Verbose "Querying permissions for GPO: $($gpoName) ($($gpoId))"
                        if ([string]::IsNullOrWhiteSpace($DomainController)) { throw "Domain Controller name is missing" }
                        if (Get-Command Get-GPPermission -ErrorAction SilentlyContinue) {
                            $GpoPermissionsCache[$gpoId] = Get-GPPermission -Guid $gpoId -All -Server $DomainController -ErrorAction SilentlyContinue
                        } else {
                            Write-Log "Get-GPPermission command not found for GPO '$gpoName' ($gpoId)." -Level WARN
                            $GpoPermissionsCache[$gpoId] = $null
                        }
                    }
                    $permissions = $GpoPermissionsCache[$gpoId]
                    if ($permissions) {
                        $denyACEs = $permissions | Where-Object { $_.Type -eq 'Deny' -and $_.Permission -eq 'GpoApply' }
                        $isDenied = $false
                        foreach ($ace in $denyACEs) {
                            if ($ace.Trustee.Sid.Value -eq $userSid -or ($userGroupsSids -contains $ace.Trustee.Sid.Value)) {
                                $isDenied = $true
                                break
                            }
                        }
                        if (-not $isDenied) {
                            $allowACEs = $permissions | Where-Object { $_.Type -eq 'Allow' -and $_.Permission -eq 'GpoApply' }
                            $explicitAllow = $false
                            $groupAllows = $false
                            foreach ($ace in $allowACEs) {
                                if ($ace.Trustee.Sid.Value -eq $userSid) { $explicitAllow = $true }
                                if ($userGroupsSids -contains $ace.Trustee.Sid.Value) { $groupAllows = $true }
                            }
                            $authUsersApply = $allowACEs | Where-Object { $_.Trustee.Sid.Value -eq "S-1-5-11" }
                            if ($authUsersApply -or $explicitAllow -or $groupAllows) {
                                $appliedGpos.Add([PSCustomObject]@{
                                    UserIdentifier     = $User.$UserIdentifierProperty
                                    GpoName            = $gpoName
                                    GpoId              = $gpoId
                                    Link_Target_DN     = $ouDN
                                    Link_Order         = $link.Order
                                    IsSecurityFiltered = $true
                                    IsEnforced         = $isEnforced
                                })
                                if (!$isEnforced) { $processedGpoIds.Add($gpoId) | Out-Null }
                            } else {
                                Write-Verbose "GPO '$($gpoName)' skipped for user '$($User.$UserIdentifierProperty)' due to security filtering."
                                if (!$isEnforced) { $processedGpoIds.Add($gpoId) | Out-Null }
                            }
                        } elseif ($isDenied) {
                            Write-Verbose "GPO '$($gpoName)' skipped for user '$($User.$UserIdentifierProperty)' due to explicit Deny ACE."
                            if (!$isEnforced) { $processedGpoIds.Add($gpoId) | Out-Null }
                        }
                    } else {
                        Write-Log "Could not retrieve permissions for GPO '$($gpoName)' ($($gpoId)). Assuming applies." -Level WARN
                        $appliedGpos.Add([PSCustomObject]@{
                            UserIdentifier     = $User.$UserIdentifierProperty
                            GpoName            = $gpoName
                            GpoId              = $gpoId
                            Link_Target_DN     = $ouDN
                            Link_Order         = $link.Order
                            IsSecurityFiltered = $false
                            IsEnforced         = $isEnforced
                        })
                        if (!$isEnforced) { $processedGpoIds.Add($gpoId) | Out-Null }
                    }
                }
            }
        } catch {
            Write-Log "Error processing GPO links for target '$($ouDN)': $($_.Exception.Message)" -Level WARN
        }
        if ($ouDN -like 'OU=*') {
            try {
                if ([string]::IsNullOrWhiteSpace($DomainController)) { throw "Domain Controller name is missing" }
                $ouObject = Get-ADOrganizationalUnit -Identity $ouDN -Properties Options -Server $DomainController -ErrorAction SilentlyContinue
                if ($ouObject -and ($ouObject.Options -band 1)) {
                    Write-Verbose "Inheritance blocked at OU: $($ouDN)."
                    break
                }
            } catch {
                Write-Log "Could not check inheritance blocking for OU '$($ouDN)': $($_.Exception.Message)" -Level WARN
            }
        }
    }
    return $appliedGpos
}

function Get-GraphTransitiveGroupMembers {
    param(
        [string]$GroupId
    )
    if ([string]::IsNullOrWhiteSpace($GroupId)) { return @() }
    if ($script:GraphGroupMembershipCache.ContainsKey($GroupId)) {
        return $script:GraphGroupMembershipCache[$GroupId]
    }
    Write-Verbose "Querying Graph for transitive members of group $($GroupId)"
    try {
        $allMembers = Get-MgGroupTransitiveMember -GroupId $GroupId -All -ErrorAction Stop | Where-Object { $_.'@odata.type' -eq '#microsoft.graph.user' }
        $memberUPNs = $allMembers | ForEach-Object { $_.AdditionalProperties.userPrincipalName } | Where-Object { -not [string]::IsNullOrWhiteSpace($_) } | Select-Object -Unique
        Write-Verbose "Found $($memberUPNs.Count) transitive user members for group $($GroupId)"
        $script:GraphGroupMembershipCache[$GroupId] = $memberUPNs
        return $memberUPNs
    } catch {
        Write-Log "Error getting transitive members for Graph group $($GroupId): $($_.Exception.Message)" -Level WARN
        $script:GraphGroupMembershipCache[$GroupId] = @()
        return @()
    }
}

#endregion Core Functions

#region Main Aggregation Logic
Write-Log "=========================================================="
Write-Log " Starting User-Centric Data Aggregation (v2.10.11 - Service Principal Auth) "
Write-Log " Input Path: $($InputCsvPath)"
Write-Log " Output Path: $($OutputCsvPath)"
Write-Log " User Identifier: $($UserIdentifierProperty)"
Write-Log " Domain Controller: $($DomainController)"
Write-Log " Batch Size: $($BatchSize)"
Write-Log "=========================================================="

Write-Log "Starting Preprocessing..." -Level INFO
Check-RequiredModules
if (-not (Test-Path $InputCsvPath -PathType Container)) {
    Write-Log "Input CSV path not found: '$($InputCsvPath)'." -Level ERROR
    exit 1
}
try {
    Write-Log "Attempting to import GroupPolicy module..."
    Import-Module GroupPolicy -ErrorAction Stop
    if (-not (Get-Command Get-GPPermission -ErrorAction SilentlyContinue)) {
        Write-Log "ERROR: Get-GPPermission command not found." -Level ERROR
        exit 1
    }
} catch {
    Write-Log "Failed to import GroupPolicy module: $($_.Exception.Message)" -Level ERROR
    exit 1
}
Ensure-AggregatorConnections
Write-Log "Loading input CSV data from $($InputCsvPath)..."
$adUsersDataAll = Import-InputCsv -FileName "ADUsers"
$secGroupData = Import-InputCsv -FileName "SecurityGroups"
$secGroupMemberData = Import-InputCsv -FileName "SecurityGroupMembers"
$dlData = Import-InputCsv -FileName "DistributionLists"
$sharedMbData = Import-InputCsv -FileName "SharedMailboxes"
$mailboxesData = Import-InputCsv -FileName "Mailboxes"
$gpoData = Import-InputCsv -FileName "GroupPolicies"
$driveMapData = Import-InputCsv -FileName "DriveMappingsGPO"
$logonScriptData = Import-InputCsv -FileName "LogonScripts"
$folderRedirData = Import-InputCsv -FileName "FolderRedirectionGPO"
$printerMapData = Import-InputCsv -FileName "PrinterMappingsGPO"
$intunePolicyData = Import-InputCsv -FileName "IntuneDeviceConfigurationPolicies"
$entAppData = Import-InputCsv -FileName "EnterpriseApplications"
$appProxyData = Import-InputCsv -FileName "ApplicationProxies"
$oneDriveUsageData = Import-InputCsv -FileName "OneDriveUsage"
$teamsData = Import-InputCsv -FileName "UserTeamMemberships"
$licensingData = Import-InputCsv -FileName "UserLicenses"
$deviceInventoryData = Import-InputCsv -FileName "DeviceInventory"
$caPolicyData = Import-InputCsv -FileName "ConditionalAccessPolicies"
$caAssignmentData = Import-InputCsv -FileName "ConditionalAccessPolicyAssignments"
if (-not $adUsersDataAll) {
    Write-Log "Cannot proceed without AD Users data." -Level ERROR
    exit 1
}
if (-not $sharedMbData) {
    Write-Log "Warning: SharedMailboxes.csv not found or failed to load." -Level WARN
}
Write-Log "Creating lookup tables..." -Level INFO
$adUsersHash = $adUsersDataAll | Where-Object { $_ -ne $null -and -not [string]::IsNullOrWhiteSpace($_.$UserIdentifierProperty) } | Group-Object -Property $UserIdentifierProperty -AsHashTable -AsString
$adUsersBySAM = $adUsersDataAll | Where-Object { $_ -ne $null -and -not [string]::IsNullOrWhiteSpace($_.SamAccountName) } | Group-Object -Property SamAccountName -AsHashTable -AsString
$adUsersByDN = $adUsersDataAll | Where-Object { $_ -ne $null -and -not [string]::IsNullOrWhiteSpace($_.DistinguishedName) } | Group-Object -Property DistinguishedName -AsHashTable -AsString
$adUsersByUPN = $adUsersDataAll | Where-Object { $_ -ne $null -and -not [string]::IsNullOrWhiteSpace($_.UserPrincipalName) } | Group-Object -Property UserPrincipalName -AsHashTable -AsString
$secGroupsHash = $secGroupData | Where-Object { $_ -ne $null -and -not [string]::IsNullOrWhiteSpace($_.SamAccountName) } | Group-Object -Property SamAccountName -AsHashTable -AsString
$gpoHash = $gpoData | Where-Object { $_ -ne $null } | ForEach-Object { $_.Id = $_.Id.ToString(); $_ } | Group-Object -Property Id -AsHashTable -AsString
$intunePolicyHash = $intunePolicyData | Where-Object { $_ -ne $null } | Group-Object -Property PolicyId -AsHashTable -AsString
$entAppHash = $entAppData | Where-Object { $_ -ne $null -and -not [string]::IsNullOrWhiteSpace($_.AppId) } | Group-Object -Property AppId -AsHashTable -AsString
$oneDriveUsageHash = $oneDriveUsageData | Where-Object { $_ -ne $null -and -not [string]::IsNullOrWhiteSpace($_.UserPrincipalName) } | Group-Object -Property UserPrincipalName -AsHashTable -AsString
$caPolicyHash = $caPolicyData | Where-Object { $_ -ne $null } | Group-Object -Property Id -AsHashTable -AsString
Write-Log "Preprocessing Group Memberships and SIDs..." -Level INFO
$validSecGroupMemberData = $secGroupMemberData | Where-Object { $_ -ne $null -and -not([string]::IsNullOrWhiteSpace($_.MemberSamAccountName)) -and -not([string]::IsNullOrWhiteSpace($_.GroupSamAccountName)) -and -not([string]::IsNullOrWhiteSpace($_.GroupDN)) }
$userGroupMembershipsAD_Groups = $validSecGroupMemberData | Group-Object -Property MemberSamAccountName -AsHashTable -AsString
$userGroupMembershipsAD = @{}
if ($userGroupMembershipsAD_Groups) {
    foreach ($groupEntry in $userGroupMembershipsAD_Groups.GetEnumerator()) {
        $userSAM = $groupEntry.Name
        $groupList = $groupEntry.Value
        $groupDNs = $groupList | ForEach-Object {
            if ($secGroupsHash.ContainsKey($_.GroupSamAccountName)) {
                $secGroupsHash[$_.GroupSamAccountName][0].DistinguishedName
            } else {
                Write-Log "Group SAM '$($_.GroupSamAccountName)' not found in SecurityGroups data for user '$($userSAM)'." -Level WARN
                $null
            }
        } | Where-Object { -not [string]::IsNullOrWhiteSpace($_) } | Select-Object -Unique
        if ($groupDNs) {
            $userGroupMembershipsAD[$userSAM] = $groupDNs
        }
    }
}
Write-Log "Fetching AD Group SIDs for GPO filtering..." -Level INFO
$groupSidCache = @{}
$allGroupDNsInMemberships = $validSecGroupMemberData | Select-Object -ExpandProperty GroupDN -Unique | Where-Object { -not [string]::IsNullOrWhiteSpace($_) }
$i_grp = 0
$totalGroupsToQuery = $allGroupDNsInMemberships.Count
Write-Log "Querying SIDs for $($totalGroupsToQuery) unique groups..."
foreach ($groupDN in $allGroupDNsInMemberships) {
    $i_grp++
    Write-Progress -Activity "Fetching Group SIDs" -Status "Processing group $($i_grp) of $($totalGroupsToQuery)" -PercentComplete (($i_grp / $totalGroupsToQuery) * 100)
    try {
        $group = Get-ADGroup -Identity $groupDN -Properties SID -Server $DomainController -ErrorAction Stop
        $groupSidCache[$groupDN] = $group.SID.Value
    } catch {
        Write-Log "Could not get SID for group '$($groupDN)': $($_.Exception.Message)" -Level WARN
    }
}
Write-Progress -Activity "Fetching Group SIDs" -Completed
$userGroupSidsAD = @{}
foreach ($userSAM in ($userGroupMembershipsAD.Keys | Where-Object { $_ })) {
    $groupDNs = $userGroupMembershipsAD[$userSAM] | Where-Object { $_ }
    $sids = $groupDNs | ForEach-Object { $groupSidCache[$_] } | Where-Object { $_ }
    if ($sids) {
        $userGroupSidsAD[$userSAM] = $sids
    }
}


# Replace the SID retrieval section in the preprocessing phase
Write-Log "Ensuring User SIDs are available..." -Level INFO
$userSidCache = @{}
# Validate Domain Controller connectivity
try {
    Write-Verbose "Testing connectivity to Domain Controller: $DomainController"
    $dcInfo = Get-ADDomainController -Identity $DomainController -ErrorAction Stop
    Write-Log "Domain Controller '$DomainController' is reachable." -Level INFO
} catch {
    Write-Log "Failed to connect to Domain Controller '$DomainController': $($_.Exception.Message)" -Level ERROR
    Write-Log "Cannot proceed with SID retrieval. Please verify the DomainController parameter." -Level ERROR
    exit 1
}
foreach ($userRow in $adUsersDataAll) {
    $userSamAccount = $userRow.SamAccountName
    if (-not $userSamAccount) {
        Write-Log "Skipping user record with missing SamAccountName (UPN: $($userRow.UserPrincipalName))" -Level WARN
        continue
    }
    # Validate SamAccountName format (basic check for length and characters)
    if ($userSamAccount -notmatch '^[a-zA-Z0-9][a-zA-Z0-9\-_\.]{0,19}$' -or $userSamAccount.Length -gt 20) {
        Write-Log "Invalid SamAccountName '$userSamAccount' (UPN: $($userRow.UserPrincipalName)). Skipping SID query." -Level WARN
        if (-not $userRow.PSObject.Properties['SID']) { $userRow | Add-Member -MemberType NoteProperty -Name SID -Value $null }
        else { $userRow.SID = $null }
        $userSidCache[$userSamAccount] = $null
        continue
    }
    $sidValue = $null
    if ($userRow.PSObject.Properties['SID']) {
        $sidValue = $userRow.SID
    }
    if (-not $sidValue -or ($sidValue -is [string] -and $sidValue.Length -lt 5) -or ($sidValue -is [System.Security.Principal.SecurityIdentifier] -and -not $sidValue.Value)) {
        try {
            Write-Verbose "Querying missing/invalid SID for user '$userSamAccount'"
            $userObj = Get-ADUser -Identity $userSamAccount -Properties SID -Server $DomainController -ErrorAction Stop
            if (-not $userObj.SID) {
                throw "SID not returned for user '$userSamAccount'"
            }
            $userSidValue = $userObj.SID.Value
            if ($userRow.PSObject.Properties['SID']) { $userRow.SID = $userSidValue }
            else { $userRow | Add-Member -MemberType NoteProperty -Name SID -Value $userSidValue }
            $userSidCache[$userSamAccount] = $userSidValue
            Write-Verbose "Retrieved SID '$userSidValue' for user '$userSamAccount'"
        } catch {
            $errorDetails = $_.Exception.Message
            if ($_.Exception -is [Microsoft.ActiveDirectory.Management.ADError]) {
                $errorDetails += "; ErrorCode: $($_.Exception.ErrorCode)"
            }
            Write-Log "Could not get SID for user '$userSamAccount' (UPN: $($userRow.UserPrincipalName)): $errorDetails" -Level WARN
            if (-not $userRow.PSObject.Properties['SID']) { $userRow | Add-Member -MemberType NoteProperty -Name SID -Value $null }
            else { $userRow.SID = $null }
            $userSidCache[$userSamAccount] = $null
        }
    } else {
        $userSidValue = if ($sidValue -is [System.Security.Principal.SecurityIdentifier]) { $sidValue.Value } else { $sidValue }
        $userSidCache[$userSamAccount] = $userSidValue
        $userRow.SID = $userSidValue
    }
}



Write-Log "Preprocessing Shared Mailbox Permissions from CSV..." -Level INFO
$userToSharedMailboxPermsLookup = @{}
if ($sharedMbData) {
    $reqCols = @('PrimarySmtpAddress', 'Permissions', 'SendAs')
    $props = $sharedMbData | Select-Object -First 1 | Get-Member -MemberType NoteProperty | Select-Object -ExpandProperty Name
    $missingCols = $reqCols | Where-Object { $props -notcontains $_ }
    if ($missingCols) {
        Write-Log "Warning: SharedMailboxes.csv missing required columns: $($missingCols -join ', '). Skipping permission processing." -Level WARN
        $sharedMbData = $null
    } else {
        $i_smb_parse = 0; $totalSmb = $sharedMbData.Count
        foreach ($smb in $sharedMbData) {
            $i_smb_parse++; Write-Progress -Activity "Parsing Shared Mailbox Permissions from CSV" -Status "Processing mailbox $i_smb_parse of $totalSmb" -PercentComplete (($i_smb_parse / $totalSmb) * 100)
            $smbAddress = $smb.PrimarySmtpAddress
            if ([string]::IsNullOrWhiteSpace($smbAddress)) { continue }
            if (-not [string]::IsNullOrWhiteSpace($smb.Permissions) -and $smb.Permissions -ne "Not Queried" -and $smb.Permissions -ne "ERROR") {
                $fullAccessEntries = $smb.Permissions -split ';' | Where-Object { $_ -match ':' }
                foreach ($entry in $fullAccessEntries) {
                    $parts = $entry -split ':', 2
                    $grantee = $parts[0].Trim()
                    $rights = $parts[1].Trim()
                    if ([string]::IsNullOrWhiteSpace($grantee)) { continue }
                    if (-not $userToSharedMailboxPermsLookup.ContainsKey($grantee)) { $userToSharedMailboxPermsLookup[$grantee] = [System.Collections.Generic.List[PSCustomObject]]::new() }
                    $userToSharedMailboxPermsLookup[$grantee].Add([PSCustomObject]@{
                        SharedMailbox_PrimarySmtpAddress = $smbAddress
                        PermissionType                 = "FullAccess"
                        AccessRights                   = $rights
                        GrantedViaIdentifier           = $grantee
                    })
                }
            }
            if (-not [string]::IsNullOrWhiteSpace($smb.SendAs) -and $smb.SendAs -ne "Not Queried" -and $smb.SendAs -ne "ERROR") {
                $sendAsEntries = $smb.SendAs -split ';' | Where-Object { $_ -match ':' }
                foreach ($entry in $sendAsEntries) {
                    $grantee = ($entry -split ':', 2)[0].Trim()
                    if ([string]::IsNullOrWhiteSpace($grantee)) { continue }
                    if (-not $userToSharedMailboxPermsLookup.ContainsKey($grantee)) { $userToSharedMailboxPermsLookup[$grantee] = [System.Collections.Generic.List[PSCustomObject]]::new() }
                    if (-not ($userToSharedMailboxPermsLookup[$grantee] | Where-Object {$_.SharedMailbox_PrimarySmtpAddress -eq $smbAddress -and $_.PermissionType -eq "SendAs"})) {
                        $userToSharedMailboxPermsLookup[$grantee].Add([PSCustomObject]@{
                            SharedMailbox_PrimarySmtpAddress = $smbAddress
                            PermissionType                 = "SendAs"
                            AccessRights                   = "SendAs"
                            GrantedViaIdentifier           = $grantee
                        })
                    }
                }
            }
        }
        Write-Progress -Activity "Parsing Shared Mailbox Permissions from CSV" -Completed
    }
} else {
    Write-Log "Skipping Shared Mailbox permission preprocessing as SharedMailboxes.csv was not loaded." -Level WARN
}
Write-Log "Finished preprocessing Shared Mailbox Permissions from CSV." -Level INFO
Write-Log "Preprocessing Conditional Access Policy Assignments..." -Level INFO
$caAssignmentLookup = @{}
if ($caAssignmentData) {
    foreach ($assignment in $caAssignmentData) {
        $targetId = $assignment.TargetId
        $policyId = $assignment.PolicyId
        $assignmentType = $assignment.AssignmentType
        if ([string]::IsNullOrWhiteSpace($targetId)) { continue }
        if (-not $caAssignmentLookup.ContainsKey($targetId)) { $caAssignmentLookup[$targetId] = [System.Collections.Generic.List[PSCustomObject]]::new() }
        $caAssignmentLookup[$targetId].Add([PSCustomObject]@{
            PolicyId       = $policyId
            AssignmentType = $assignmentType
        })
    }
} else {
    Write-Log "No Conditional Access Assignment data found to preprocess." -Level WARN
}
Write-Log "Finished preprocessing Conditional Access Policy Assignments." -Level INFO
Write-Log "Preprocessing Finished Successfully." -Level INFO

try {
    if (-not $adUsersDataAll -or $adUsersDataAll.Count -eq 0) {
        Write-Log "Critical error: AD Users data is missing or empty." -Level ERROR
        exit 1
    }
    $totalUserCount = $adUsersDataAll.Count
    $processedUserCountTotal = 0
    $usersToProcess = $null
    $lastProcessedUserId = $null
    $startIndex = 0
    if (Test-Path $script:StateFilePath -PathType Leaf) {
        try {
            $lastProcessedUserId = Get-Content $script:StateFilePath -ErrorAction Stop
            Write-Log "Found state file. Last processed user: $($lastProcessedUserId)" -Level INFO
            $lastIndex = -1
            for ($idx = 0; $idx -lt $adUsersDataAll.Count; $idx++) {
                if ($adUsersDataAll[$idx].PSObject.Properties[$UserIdentifierProperty] -ne $null -and $adUsersDataAll[$idx].$UserIdentifierProperty -eq $lastProcessedUserId) {
                    $lastIndex = $idx
                    break
                }
            }
            if ($lastIndex -ge 0) {
                $startIndex = $lastIndex + 1
                if ($startIndex -ge $totalUserCount) {
                    Write-Log "All users were already processed according to state file." -Level INFO
                    $usersToProcess = [System.Collections.Generic.List[PSCustomObject]]::new()
                    $processedUserCountTotal = $totalUserCount
                } else {
                    $remainingUsersArray = $adUsersDataAll[$startIndex..($totalUserCount - 1)]
                    $usersToProcess = [System.Collections.Generic.List[PSCustomObject]]::new()
                    $usersToProcess.AddRange([PSCustomObject[]]$remainingUsersArray)
                    $processedUserCountTotal = $startIndex
                    if ($usersToProcess.Count -gt 0) {
                        Write-Log "Resuming from user #$($startIndex + 1) ($($usersToProcess[0].$UserIdentifierProperty)). $($usersToProcess.Count) users remaining." -Level INFO
                    } else {
                        Write-Log "Resuming processing, but remaining user list is empty." -Level WARN
                    }
                }
            } else {
                Write-Log "Last processed user '$($lastProcessedUserId)' not found. Processing all users." -Level WARN
                $usersToProcess = [System.Collections.Generic.List[PSCustomObject]]::new()
                $usersToProcess.AddRange([PSCustomObject[]]$adUsersDataAll)
            }
        } catch {
            Write-Log "Error reading state file '$($script:StateFilePath)': $($_.Exception.Message). Processing all users." -Level WARN
            $usersToProcess = [System.Collections.Generic.List[PSCustomObject]]::new()
            $usersToProcess.AddRange([PSCustomObject[]]$adUsersDataAll)
        }
    } else {
        Write-Log "No state file found. Processing all users." -Level INFO
        $usersToProcess = [System.Collections.Generic.List[PSCustomObject]]::new()
        $usersToProcess.AddRange([PSCustomObject[]]$adUsersDataAll)
    }
    if ($null -eq $usersToProcess) {
        Write-Log "Critical error: Failed to initialize \$usersToProcess list." -Level ERROR
        exit 1
    }
    $batchUsersCore = [System.Collections.Generic.List[PSCustomObject]]::new()
    $batchUserSecGroupMembership = [System.Collections.Generic.List[PSCustomObject]]::new()
    $batchUserDlMembership = [System.Collections.Generic.List[PSCustomObject]]::new()
    $batchUserSharedMbPerms = [System.Collections.Generic.List[PSCustomObject]]::new()
    $batchUserAppliedGpos = [System.Collections.Generic.List[PSCustomObject]]::new()
    $batchUserIntuneAssignments = [System.Collections.Generic.List[PSCustomObject]]::new()
    $batchUserAppAssignments = [System.Collections.Generic.List[PSCustomObject]]::new()
    $batchUserLogonScripts = [System.Collections.Generic.List[PSCustomObject]]::new()
    $batchUserDriveMaps = [System.Collections.Generic.List[PSCustomObject]]::new()
    $batchUserFolderRedir = [System.Collections.Generic.List[PSCustomObject]]::new()
    $batchUserPrinterMaps = [System.Collections.Generic.List[PSCustomObject]]::new()
    $batchUserTeamMembership = [System.Collections.Generic.List[PSCustomObject]]::new()
    $batchUserLicenseAssignments = [System.Collections.Generic.List[PSCustomObject]]::new()
    $batchUserDevices = [System.Collections.Generic.List[PSCustomObject]]::new()
    $batchUserCAPolicyAssignments = [System.Collections.Generic.List[PSCustomObject]]::new()
    $gpoPermissionsCache = @{}
    $gpoLinkCache = @{}
    $script:GraphGroupMembershipCache = @{}
    $graphUserIdCache = @{}
    $graphGroupDetailCache = @{}
    $graphRoleDetailCache = @{}
    Write-Log "Processing $($usersToProcess.Count) users..."
    $currentBatchUserCount = 0
    $lastUserProcessedInBatch = $null
    foreach ($user in $usersToProcess) {
        $processedUserCountTotal++
        $currentBatchUserCount++
        if (-not $user.$UserIdentifierProperty -or [string]::IsNullOrWhiteSpace($user.$UserIdentifierProperty) -or
            -not $user.SamAccountName -or [string]::IsNullOrWhiteSpace($user.SamAccountName)) {
            Write-Log "Skipping user record #$($processedUserCountTotal) due to missing identifiers." -Level WARN
            continue
        }
        $userId = $user.$UserIdentifierProperty
        $userSam = $user.SamAccountName
        $userUPN = $user.UserPrincipalName
        $userEmail = $user.mail
        $userDN = $user.DistinguishedName
        $userSID = $user.SID
        Write-Progress -Activity "Aggregating User Data" -Status "Processing user $processedUserCountTotal of $totalUserCount ($userId)" -PercentComplete (($processedUserCountTotal / $totalUserCount) * 100)
        Write-Verbose "Processing User: $userId (SAM: $userSam)"
        $userGraphId = $null
        if (-not $script:GraphConnectionFailed -and $userUPN -and -not [string]::IsNullOrWhiteSpace($userUPN)) {
            if ($graphUserIdCache.ContainsKey($userUPN)) {
                $userGraphId = $graphUserIdCache[$userUPN]
            } else {
                try {
                    Write-Verbose "Querying Graph ID for $userUPN"
                    $graphUser = Get-MgUser -UserId $userUPN -Property Id -ErrorAction Stop
                    $userGraphId = $graphUser.Id
                    $graphUserIdCache[$userUPN] = $userGraphId
                } catch {
                    $exceptionType = $_.Exception.GetType().FullName
                    $exceptionMessage = $_.Exception.Message
                    Write-Log "Error getting Graph ID for user '$userUPN'. Type: $exceptionType" -Level WARN
                    try { Write-Log "Error Message: $exceptionMessage" -Level WARN } catch { Write-Log "Failed to log error message: $($_.Exception.Message)" -Level ERROR }
                    if ($exceptionMessage -match 'Authentication needed' -or $exceptionMessage -match 'Token has expired') {
                        Write-Log "Attempting reconnect for user '$userUPN'..." -Level WARN
                        if (Ensure-AggregatorConnections) {
                            try {
                                $graphUser = Get-MgUser -UserId $userUPN -Property Id -ErrorAction Stop
                                $userGraphId = $graphUser.Id
                                $graphUserIdCache[$userUPN] = $userGraphId
                                Write-Log "Retrieved Graph ID after reconnect." -Level INFO
                            } catch {
                                Write-Log "Still could not get Graph ID after reconnect: $($_.Exception.Message)" -Level WARN
                                $graphUserIdCache[$userUPN] = $null
                            }
                        } else {
                            Write-Log "Reconnect failed." -Level ERROR
                            $graphUserIdCache[$userUPN] = $null
                        }
                    } elseif ($exceptionMessage -match 'Resource .* does not exist') {
                        Write-Log "User '$userUPN' not found in Graph." -Level INFO
                        $graphUserIdCache[$userUPN] = $null
                    } else {
                        $graphUserIdCache[$userUPN] = $null
                    }
                }
            }
        }
        $userOU = $null
        if ($userDN -match '(OU=|CN=Users|CN=Computers)') { $userOU = $userDN -replace '^CN=.*?,(OU=.*)$','$1' -replace '^CN=.*?,(CN=(Users|Computers).*)$','$1' }
        $user | Add-Member -MemberType NoteProperty -Name AD_OU -Value $userOU -Force -ErrorAction SilentlyContinue
        $managerSam = $null
        if ($user.manager) {
            try {
                $managerObj = Get-ADUser -Identity $user.manager -Properties SamAccountName -Server $DomainController -ErrorAction SilentlyContinue
                if ($managerObj) { $managerSam = $managerObj.SamAccountName }
            } catch {
                Write-Verbose "Could not resolve manager SAM for user '$userSam' (Manager DN: $($user.manager))"
            }
        }
        $user | Add-Member -MemberType NoteProperty -Name Manager_SamAccountName -Value $managerSam -Force -ErrorAction SilentlyContinue
        if ($oneDriveUsageHash -and $userUPN -and $oneDriveUsageHash.ContainsKey($userUPN)) {
            $oneDriveInfo = $oneDriveUsageHash[$userUPN][0]
            $user | Add-Member -MemberType NoteProperty -Name OneDrive_QuotaTotal -Value $oneDriveInfo.StorageAllocatedBytes -Force -ErrorAction SilentlyContinue
            $user | Add-Member -MemberType NoteProperty -Name OneDrive_QuotaUsed -Value $oneDriveInfo.StorageUsedBytes -Force -ErrorAction SilentlyContinue
            $user | Add-Member -MemberType NoteProperty -Name OneDrive_QuotaState -Value $oneDriveInfo.StorageRemainingBytes -Force -ErrorAction SilentlyContinue
            $user | Add-Member -MemberType NoteProperty -Name OneDrive_DriveId -Value $oneDriveInfo.DriveId -Force -ErrorAction SilentlyContinue
        } else {
            $user | Add-Member -MemberType NoteProperty -Name OneDrive_QuotaTotal -Value $null -Force -ErrorAction SilentlyContinue
            $user | Add-Member -MemberType NoteProperty -Name OneDrive_QuotaUsed -Value $null -Force -ErrorAction SilentlyContinue
            $user | Add-Member -MemberType NoteProperty -Name OneDrive_QuotaState -Value "NotFoundOrError" -Force -ErrorAction SilentlyContinue
            $user | Add-Member -MemberType NoteProperty -Name OneDrive_DriveId -Value $null -Force -ErrorAction SilentlyContinue
        }
        $user | Add-Member -MemberType NoteProperty -Name AzureADObjectId -Value $userGraphId -Force -ErrorAction SilentlyContinue
        $coreProps = $user.PSObject.Properties | Where-Object {$_.MemberType -in @('NoteProperty', 'AliasProperty', 'ScriptProperty')} | Select-Object -ExpandProperty Name
        $excludedProps = @('PropertyNames', 'PropertyCount', 'Count', 'Length', 'SyncRoot', 'IsReadOnly', 'IsFixedSize', 'IsSynchronized', 'Item', 'PSStandardMembers', 'PSAdapted', 'PSBase', 'PSTypeNames', 'PSObject')
        $propsToSelect = $coreProps | Where-Object {$_ -notin $excludedProps}
        $batchUsersCore.Add(($user | Select-Object -Property $propsToSelect))
        if ($userGroupMembershipsAD.ContainsKey($userSam)) {
            $userGroupMembershipsAD[$userSam] | ForEach-Object {
                $groupDN = $_
                $groupInfo = $secGroupData | Where-Object {$_.DistinguishedName -eq $groupDN}
                if ($groupInfo) {
                    $groupInfo = $groupInfo[0]
                    $batchUserSecGroupMembership.Add([PSCustomObject]@{
                        UserIdentifier      = $userId
                        GroupSamAccountName = $groupInfo.SamAccountName
                        GroupName           = $groupInfo.Name
                        GroupDN             = $groupDN
                        GroupCategory       = $groupInfo.GroupCategory
                        GroupScope          = $groupInfo.GroupScope
                    })
                }
            }
        }
        if ($dlData) {
            foreach ($dl in $dlData) {
                if ($dl.PSObject.Properties.Name -contains 'Members' -and $dl.Members) {
                    $memberString = $dl.Members.ToLower()
                    $isMember = $false
                    if ($userEmail -and $memberString -like "*$($userEmail.ToLower())*") { $isMember = $true }
                    elseif ($userUPN -and $memberString -like "*$($userUPN.ToLower())*") { $isMember = $true }
                    elseif ($userSam -and $memberString -like "*$($userSam.ToLower())*") { $isMember = $true }
                    if ($isMember) {
                        $batchUserDlMembership.Add([PSCustomObject]@{
                            UserIdentifier          = $userId
                            DL_PrimarySmtpAddress = $dl.PrimarySmtpAddress
                            DL_DisplayName        = $dl.DisplayName
                            DL_GroupType          = $dl.GroupType
                        })
                    }
                }
            }
        }
        if ($userToSharedMailboxPermsLookup) {
            $userKeys = @($userUPN, $userSam) | Where-Object { -not [string]::IsNullOrWhiteSpace($_) } | Select-Object -Unique
            foreach ($key in $userKeys) {
                if ($userToSharedMailboxPermsLookup.ContainsKey($key)) {
                    foreach ($perm in $userToSharedMailboxPermsLookup[$key]) {
                        if (-not ($batchUserSharedMbPerms | Where-Object {$_.UserIdentifier -eq $userId -and $_.SharedMailbox_PrimarySmtpAddress -eq $perm.SharedMailbox_PrimarySmtpAddress -and $_.PermissionType -eq $perm.PermissionType})) {
                            $batchUserSharedMbPerms.Add([PSCustomObject]@{
                                UserIdentifier                  = $userId
                                SharedMailbox_PrimarySmtpAddress = $perm.SharedMailbox_PrimarySmtpAddress
                                PermissionType                 = $perm.PermissionType
                                AccessRights                   = $perm.AccessRights
                                GrantedViaType                 = "DirectUserOrSAM"
                                GrantedViaIdentifier           = $perm.GrantedViaIdentifier
                            })
                        }
                    }
                }
            }
            if ($userGroupMembershipsAD.ContainsKey($userSam)) {
                $userADGroupsSAMs = $userGroupMembershipsAD[$userSam] | ForEach-Object {
                    $groupDN = $_
                    $groupInfo = $secGroupData | Where-Object {$_.DistinguishedName -eq $groupDN}
                    if ($groupInfo) { $groupInfo[0].SamAccountName } else { $null }
                } | Where-Object { $_ }
                foreach ($groupSAM in $userADGroupsSAMs) {
                    if ($userToSharedMailboxPermsLookup.ContainsKey($groupSAM)) {
                        foreach ($perm in $userToSharedMailboxPermsLookup[$groupSAM]) {
                            if (-not ($batchUserSharedMbPerms | Where-Object {$_.UserIdentifier -eq $userId -and $_.SharedMailbox_PrimarySmtpAddress -eq $perm.SharedMailbox_PrimarySmtpAddress -and $_.PermissionType -eq $perm.PermissionType})) {
                                $batchUserSharedMbPerms.Add([PSCustomObject]@{
                                    UserIdentifier                  = $userId
                                    SharedMailbox_PrimarySmtpAddress = $perm.SharedMailbox_PrimarySmtpAddress
                                    PermissionType                 = $perm.PermissionType
                                    AccessRights                   = $perm.AccessRights
                                    GrantedViaType                 = "ADGroup"
                                    GrantedViaIdentifier           = $groupSAM
                                })
                            }
                        }
                    }
                }
            }
        }
        $userGpos = $null
        if ($userSID) {
            $userGpos = Get-AppliedGPOsForUser -User $user -UserGroupMembershipSids $userGroupSidsAD -GpoPermissionsCache $gpoPermissionsCache -GpoLinkCache $gpoLinkCache
            if ($userGpos -ne $null -and $userGpos.Count -gt 0) {
                $batchUserAppliedGpos.AddRange($userGpos)
            }
        } else {
            Write-Log "Skipping GPO calculation for $userId because user SID is missing." -Level WARN
        }
        if ($logonScriptData) {
            $adScript = $logonScriptData | Where-Object { $_.Source -eq 'UserObject' -and $_.UserPrincipalName -eq $userUPN }
            if ($adScript) {
                $batchUserLogonScripts.Add([PSCustomObject]@{
                    UserIdentifier = $userId
                    ScriptPath     = $adScript.ScriptPath
                    Parameters     = $adScript.ScriptName
                    SourceType     = $adScript.Source
                    SourceName     = $adScript.UserPrincipalName
                })
            }
            if ($userGpos) {
                $appliedGpoIds = $userGpos | Select-Object -ExpandProperty GpoId -Unique
                $gpoScripts = $logonScriptData | Where-Object { $_.Source -eq 'GPO' -and $_.GPOName -in ($userGpos | Select-Object -ExpandProperty GpoName) }
                foreach ($scriptItem in $gpoScripts) {
                    if (-not ($batchUserLogonScripts | Where-Object {$_.UserIdentifier -eq $userId -and $_.ScriptPath -eq $scriptItem.ScriptPath -and $_.SourceName -eq $scriptItem.GPOName})) {
                        $batchUserLogonScripts.Add([PSCustomObject]@{
                            UserIdentifier = $userId
                            ScriptPath     = $scriptItem.ScriptPath
                            Parameters     = $scriptItem.ScriptName
                            SourceType     = $scriptItem.Source
                            SourceName     = $scriptItem.GPOName
                        })
                    }
                }
            }
        }
        if ($driveMapData -and $userGpos) {
            $appliedGpoIds = $userGpos | Select-Object -ExpandProperty GpoId -Unique
            $userDriveMaps = $driveMapData | Where-Object { $_.GpoId -in $appliedGpoIds }
            foreach ($map in $userDriveMaps) {
                if (-not ($batchUserDriveMaps | Where-Object {$_.UserIdentifier -eq $userId -and $_.DriveLetter -eq $map.DriveLetter -and $_.LocationPath -eq $map.Path})) {
                    $batchUserDriveMaps.Add([PSCustomObject]@{
                        UserIdentifier = $userId
                        DriveLetter    = $map.DriveLetter
                        LocationPath   = $map.Path
                        GpoName        = $map.GPOName
                    })
                }
            }
        }
        if ($folderRedirData -and $userGpos) {
            $appliedGpoIds = $userGpos | Select-Object -ExpandProperty GpoId -Unique
            $userFolderRedir = $folderRedirData | Where-Object { $_.GpoId -in $appliedGpoIds }
            foreach ($redir in $userFolderRedir) {
                if (-not ($batchUserFolderRedir | Where-Object {$_.UserIdentifier -eq $userId -and $_.FolderName -eq $redir.FolderName})) {
                    $batchUserFolderRedir.Add([PSCustomObject]@{
                        UserIdentifier = $userId
                        FolderName     = $redir.FolderName
                        RedirectPath   = $redir.TargetPath
                        GpoName        = $redir.GPOName
                    })
                }
            }
        }
        if ($printerMapData -and $userGpos) {
            $appliedGpoIds = $userGpos | Select-Object -ExpandProperty GpoId -Unique
            $userPrinterMaps = $printerMapData | Where-Object { $_.GpoId -in $appliedGpoIds }
            foreach ($map in $userPrinterMaps) {
                if (-not ($batchUserPrinterMaps | Where-Object {$_.UserIdentifier -eq $userId -and $_.UNCPath -eq $map.PrinterPath})) {
                    $batchUserPrinterMaps.Add([PSCustomObject]@{
                        UserIdentifier = $userId
                        UNCPath        = $map.PrinterPath
                        Action         = $map.DefaultPrinter
                        IsDefault      = $map.DefaultPrinter
                        GpoName        = $map.GPOName
                    })
                }
            }
        }
        if (-not $script:GraphConnectionFailed -and $userGraphId) {
            $userGraphGroupIds = @()
            try {
                $userGraphGroupIds = Get-MgUserTransitiveMemberOf -UserId $userGraphId -All -ErrorAction Stop | Where-Object { $_.'@odata.type' -eq '#microsoft.graph.group' } | Select-Object -ExpandProperty Id -Unique
            } catch {
                Write-Log "Error getting Graph group membership for user '$userId' (GraphID: $userGraphId): $($_.Exception.Message)" -Level WARN
            }
            if ($intunePolicyData) {
                foreach ($policy in $intunePolicyData) {
                    try {
                        $assignments = Get-MgDeviceManagementDeviceConfigurationAssignment -DeviceConfigurationId $policy.PolicyId -ErrorAction Stop
                        foreach ($assignment in $assignments) {
                            $target = $assignment.Target
                            $assignmentApplies = $false
                            $assignmentSourceType = "Unknown"
                            $assignmentSourceId = "Unknown"
                            $assignmentIntent = $assignment.Intent
                            if ($target -is [Microsoft.Open.MSGraph.Model.GroupAssignmentTarget]) {
                                $targetGroupId = $target.GroupId
                                $assignmentSourceType = "Group"
                                $assignmentSourceId = $targetGroupId
                                if ($userGraphGroupIds -contains $targetGroupId) {
                                    $assignmentApplies = $true
                                }
                            } elseif ($target -is [Microsoft.Open.MSGraph.Model.AllUsersAssignmentTarget]) {
                                $assignmentApplies = $true
                                $assignmentSourceType = "AllUsers"
                                $assignmentSourceId = "AllUsers"
                            } elseif ($target -is [Microsoft.Open.MSGraph.Model.AllDevicesAssignmentTarget]) {
                                continue
                            }
                            if ($assignmentApplies) {
                                $batchUserIntuneAssignments.Add([PSCustomObject]@{
                                    UserIdentifier       = $userId
                                    PolicyId             = $policy.PolicyId
                                    PolicyName           = $policy.DisplayName
                                    PolicyPlatform       = $policy.PlatformType
                                    AssignmentIntent     = $assignmentIntent
                                    AssignmentSourceType = $assignmentSourceType
                                    AssignmentSourceId   = $assignmentSourceId
                                })
                            }
                        }
                    } catch {
                        Write-Log "Error getting assignments for Intune policy '$($policy.DisplayName)' ($($policy.PolicyId)): $($_.Exception.Message)" -Level WARN
                    }
                }
            }
            if ($entAppData) {
                try {
                    $appAssignments = @()
                    $directAssignments = Get-MgUserAppRoleAssignment -UserId $userGraphId -All -ErrorAction Stop
                    if ($directAssignments) {$appAssignments += $directAssignments}
                    if ($userGraphGroupIds) {
                        foreach ($groupId in $userGraphGroupIds) {
                            try {
                                $groupAppAssignments = Get-MgGroupAppRoleAssignment -GroupId $groupId -All -ErrorAction Stop
                                if ($groupAppAssignments) { $appAssignments += $groupAppAssignments }
                            } catch {
                                Write-Log "Error getting app assignments for group $groupId: $($_.Exception.Message)" -Level WARN
                            }
                        }
                    }
                    $processedAppAssignmentKeys = [System.Collections.Generic.HashSet[string]]::new()
                    foreach ($assignment in $appAssignments) {
                        $servicePrincipalId = $assignment.ResourceId
                        $appRoleId = $assignment.AppRoleId
                        $principalId = $assignment.PrincipalId
                        $principalType = $assignment.PrincipalType
                        $assignmentKey = "$userId-$servicePrincipalId-$appRoleId"
                        if ($processedAppAssignmentKeys.Contains($assignmentKey)) { continue }
                        $appRoleName = "Default Access"
                        $appName = "Unknown App"
                        $appId = "Unknown AppId"
                        try {
                            $servicePrincipal = Get-MgServicePrincipal -ServicePrincipalId $servicePrincipalId -Property AppId, DisplayName, AppRoles -ErrorAction Stop
                            if ($servicePrincipal) {
                                $appName = $servicePrincipal.DisplayName
                                $appId = $servicePrincipal.AppId
                                if ($appRoleId -ne '00000000-0000-0000-0000-000000000000' -and $servicePrincipal.AppRoles) {
                                    $appRole = $servicePrincipal.AppRoles | Where-Object { $_.Id -eq $appRoleId } | Select-Object -First 1
                                    if ($appRole) { $appRoleName = $appRole.DisplayName } else { $appRoleName = "Unknown Role ($appRoleId)" }
                                }
                            }
                        } catch {
                            Write-Log "Could not get SP details for $servicePrincipalId: $($_.Exception.Message)" -Level WARN
                        }
                        $assignmentSourceType = "Unknown"
                        $assignmentSourceId = $principalId
                        if ($principalType -eq 'User' -and $principalId -eq $userGraphId) {
                            $assignmentSourceType = "DirectUser"
                        } elseif ($principalType -eq 'Group' -and $userGraphGroupIds -contains $principalId) {
                            $assignmentSourceType = "Group"
                        }
                        if ($assignmentSourceType -ne "Unknown") {
                            $batchUserAppAssignments.Add([PSCustomObject]@{
                                UserIdentifier       = $userId
                                AppId                = $appId
                                AppName              = $appName
                                AssignedRoleName     = $appRoleName
                                AssignmentSourceType = $assignmentSourceType
                                AssignmentSourceId   = $assignmentSourceId
                            })
                            $processedAppAssignmentKeys.Add($assignmentKey) | Out-Null
                        }
                    }
                } catch {

Write-Log "Error getting app role assignments for user '$userId' (GraphID: $userGraphId): $($_.Exception.Message)" -Level WARN
                }
            }
            if ($teamsData) {
                $userTeams = $teamsData | Where-Object { $_.UserPrincipalName -eq $userUPN }
                foreach ($team in $userTeams) {
                    if (-not ($batchUserTeamMembership | Where-Object { $_.UserIdentifier -eq $userId -and $_.TeamId -eq $team.TeamId })) {
                        $batchUserTeamMembership.Add([PSCustomObject]@{
                            UserIdentifier     = $userId
                            TeamId             = $team.TeamId
                            TeamDisplayName    = $team.TeamDisplayName
                            MembershipRole     = $team.MembershipRole
                            Channels           = $team.Channels
                        })
                    }
                }
            }
            if ($licensingData) {
                $userLicenses = $licensingData | Where-Object { $_.UserPrincipalName -eq $userUPN }
                foreach ($license in $userLicenses) {
                    if ($license.AssignedLicenses) {
                        $licenseDetails = $license.AssignedLicenses -split '\|' | Where-Object { $_ }
                        foreach ($detail in $licenseDetails) {
                            $parts = $detail -split '\|', 2
                            $skuId = $parts[0]
                            $servicePlans = if ($parts.Count -gt 1) { $parts[1] } else { $null }
                            if (-not ($batchUserLicenseAssignments | Where-Object { $_.UserIdentifier -eq $userId -and $_.LicenseSkuId -eq $skuId })) {
                                $batchUserLicenseAssignments.Add([PSCustomObject]@{
                                    UserIdentifier    = $userId
                                    LicenseSkuId      = $skuId
                                    ServicePlans      = $servicePlans
                                })
                            }
                        }
                    }
                }
            }
            if ($deviceInventoryData) {
                $userDevices = $deviceInventoryData | Where-Object { $_.UserPrincipalName -eq $userUPN }
                foreach ($device in $userDevices) {
                    if (-not ($batchUserDevices | Where-Object { $_.UserIdentifier -eq $userId -and $_.DeviceId -eq $device.DeviceId })) {
                        $batchUserDevices.Add([PSCustomObject]@{
                            UserIdentifier    = $userId
                            DeviceId          = $device.DeviceId
                            DeviceName        = $device.DeviceName
                            Manufacturer      = $device.Manufacturer
                            Model             = $device.Model
                            OperatingSystem   = $device.OperatingSystem
                            ComplianceState   = $device.ComplianceState
                        })
                    }
                }
            }
            if ($caPolicyData -and $caAssignmentLookup -and $userGraphId) {
                if ($caAssignmentLookup.ContainsKey($userGraphId)) {
                    foreach ($assignment in $caAssignmentLookup[$userGraphId]) {
                        $policy = $caPolicyHash[$assignment.PolicyId][0]
                        if (-not ($batchUserCAPolicyAssignments | Where-Object { $_.UserIdentifier -eq $userId -and $_.PolicyId -eq $policy.Id })) {
                            $batchUserCAPolicyAssignments.Add([PSCustomObject]@{
                                UserIdentifier    = $userId
                                PolicyId          = $policy.Id
                                PolicyName        = $policy.DisplayName
                                AssignmentType    = $assignment.AssignmentType
                            })
                        }
                    }
                }
                foreach ($groupId in $userGraphGroupIds) {
                    if ($caAssignmentLookup.ContainsKey($groupId)) {
                        foreach ($assignment in $caAssignmentLookup[$groupId]) {
                            $policy = $caPolicyHash[$assignment.PolicyId][0]
                            if (-not ($batchUserCAPolicyAssignments | Where-Object { $_.UserIdentifier -eq $userId -and $_.PolicyId -eq $policy.Id })) {
                                $batchUserCAPolicyAssignments.Add([PSCustomObject]@{
                                    UserIdentifier    = $userId
                                    PolicyId          = $policy.Id
                                    PolicyName        = $policy.DisplayName
                                    AssignmentType    = "Group ($groupId)"
                                })
                            }
                        }
                    }
                }
            }
        }
        $lastUserProcessedInBatch = $userId
        if ($currentBatchUserCount -ge $BatchSize -or $processedUserCountTotal -ge $totalUserCount) {
            Write-Log "Batch complete. Users processed in batch: $currentBatchUserCount. Total processed: $processedUserCountTotal of $totalUserCount." -Level INFO
            $batchData = @{
                'UsersCore'               = $batchUsersCore
                'UserSecurityGroupMembership' = $batchUserSecGroupMembership
                'UserDistributionListMembership' = $batchUserDlMembership
                'UserSharedMailboxPermissions' = $batchUserSharedMbPerms
                'UserAppliedGPOs'         = $batchUserAppliedGpos
                'UserIntunePolicyAssignments' = $batchUserIntuneAssignments
                'UserAppAssignments'      = $batchUserAppAssignments
                'UserLogonScripts'        = $batchUserLogonScripts
                'UserDriveMappings'       = $batchUserDriveMaps
                'UserFolderRedirection'   = $batchUserFolderRedir
                'UserPrinterMappings'     = $batchUserPrinterMaps
                'UserTeamMemberships'     = $batchUserTeamMembership
                'UserLicenseAssignments'  = $batchUserLicenseAssignments
                'UserDevices'             = $batchUserDevices
                'UserConditionalAccessPolicyAssignments' = $batchUserCAPolicyAssignments
            }
            Append-BatchToCsvs -BatchData $batchData
            if ($lastUserProcessedInBatch) {
                try {
                    Set-Content -Path $script:StateFilePath -Value $lastUserProcessedInBatch -Encoding UTF8 -ErrorAction Stop
                    Write-Log "Updated state file with last processed user: $lastUserProcessedInBatch" -Level INFO
                } catch {
                    Write-Log "Error updating state file '$($script:StateFilePath)': $($_.Exception.Message)" -Level ERROR
                }
            }
            $batchUsersCore.Clear()
            $batchUserSecGroupMembership.Clear()
            $batchUserDlMembership.Clear()
            $batchUserSharedMbPerms.Clear()
            $batchUserAppliedGpos.Clear()
            $batchUserIntuneAssignments.Clear()
            $batchUserAppAssignments.Clear()
            $batchUserLogonScripts.Clear()
            $batchUserDriveMaps.Clear()
            $batchUserFolderRedir.Clear()
            $batchUserPrinterMaps.Clear()
            $batchUserTeamMembership.Clear()
            $batchUserLicenseAssignments.Clear()
            $batchUserDevices.Clear()
            $batchUserCAPolicyAssignments.Clear()
            $currentBatchUserCount = 0
            $lastUserProcessedInBatch = $null
        }
    }
    Write-Progress -Activity "Aggregating User Data" -Completed
    if ($processedUserCountTotal -eq $totalUserCount) {
        try {
            if (Test-Path $script:StateFilePath -PathType Leaf) {
                Remove-Item $script:StateFilePath -Force -ErrorAction Stop
                Write-Log "Removed state file as all users were processed." -Level INFO
            }
        } catch {
            Write-Log "Error removing state file '$($script:StateFilePath)': $($_.Exception.Message)" -Level WARN
        }
    }
    Write-Log "Aggregation complete. Total users processed: $processedUserCountTotal of $totalUserCount." -Level INFO
    if ($script:GraphConnectionFailed) {
        Write-Log "Some data was skipped due to Graph connection issues. Check logs for details." -Level WARN
    }
} finally {
    Write-Log "Cleaning up connections..." -Level INFO
    if (-not $script:GraphConnectionFailed -and (Get-MgContext)) {
        try {
            Disconnect-MgGraph -ErrorAction Stop
            Write-Log "Disconnected from Microsoft Graph." -Level INFO
        } catch {
            Write-Log "Error disconnecting from Graph: $($_.Exception.Message)" -Level WARN
        }
    }
    Write-Log "Aggregation script finished." -Level INFO
    Write-Log "Output files are located in: $OutputCsvPath" -Level INFO
    Write-Log "Log file: $script:LogPath" -Level INFO
}
#endregion Main Aggregation Logic

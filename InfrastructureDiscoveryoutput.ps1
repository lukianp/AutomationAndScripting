<#
.SYNOPSIS
    Aggregates previously discovered environment data into a user-centric relational
    model. Processes users in batches and supports resuming from the last completed batch.

.DESCRIPTION
    This script reads CSV files generated by a data discovery script.
    It processes users in batches, appending results to output CSVs incrementally.
    It saves progress to a state file, allowing the script to resume from the last
    successfully processed user if interrupted.
    It uses pre-discovered data for shared mailbox permissions and skips Graph sections on failure.
    Includes the custom Get-Gplink function and enhanced Graph connection handling.
    The output is a set of related CSV files saved to the OutputCsvPath.

.PARAMETER InputCsvPath
    The directory containing the discovery CSV files. Defaults to 'C:\DiscoveryData'.

.PARAMETER OutputCsvPath
    The mandatory directory where the aggregated CSV files will be saved.

.PARAMETER ClientId
    The Azure AD application Client ID for service principal authentication.

.PARAMETER ClientSecret
    The Azure AD application Client Secret for service principal authentication.

.PARAMETER TenantId
    The Azure AD Tenant ID for authentication.

.PARAMETER UserIdentifierProperty
    Property from ADUsers CSV for unique user ID ('UserPrincipalName' or 'SamAccountName'). Defaults to 'UserPrincipalName'.

.PARAMETER DomainController
    Domain controller for AD/GPO queries. Defaults to 'ad.zedra.com'.

.PARAMETER BatchSize
    Number of users to process before writing to output files and saving state. Defaults to 100.

.EXAMPLE
    .\Aggregate-UserCentricData_Resumable.ps1 -OutputCsvPath "C:\UserCentricOutput" -ClientId "0d16d2c2-2bf4-40f2-b4ef-20ba8dfbb7a2" -ClientSecret "your-secret" -TenantId "c405117b-3153-4ed8-8c65-b3475764ab8f"

.NOTES
    Author: Your Name/Org (Modified with community function)
    Date: 2025-05-08
    Version: 2.10.12 (Service Principal Auth, Fixed TypeNotFound)
             - Removed [Microsoft.ActiveDirectory.Management.ADError] type check in SID retrieval to prevent TypeNotFound crash.
             - Enhanced error handling in SID retrieval to log exception type and inner exception.
             - Updated Check-RequiredModules to verify ActiveDirectory module functionality.
    Version: 2.10.11 (Service Principal Auth)
             - Updated to use service principal authentication for Microsoft Graph to match discovery script
             - Added ClientId, ClientSecret, TenantId parameters
             - Updated Connect-GraphAggregator to use ClientSecretCredential
             - Adjusted column names and GPO processing to align with discovery script output
             - Removed interactive prompts for module installation
    Version: 2.10.10 (Interactive Auth)
             - Reverted to interactive user authentication for Microsoft Graph
    Version: 2.10.9 (Resumable - Fixed Finally block)
             - Wrapped main processing logic in a try block so the finally block executes correctly.
    Version: 2.10.8 (Resumable - Fixed OU Hierarchy)
             - Corrected OU hierarchy construction logic in Get-AppliedGPOsForUser to prevent DN duplication.
    Version: 2.10.7 (Resumable - Fixed AddRange cast)
             - Explicitly cast input array to [PSCustomObject[]] before calling AddRange to fix type conversion error.
    Version: 2.10.6 (Resumable - Fixed initialization)
             - Fixed "Cannot find an overload for 'new'" error during list initialization in resume logic.
    Version: 2.10.5 (Resumable)
             - Added batch processing and resume capability using a state file.
             - Replaced all '-f' string formatting in Write-Log calls with '$()' subexpressions.
             - Removed live EXO lookup for Shared Mailbox Perms, uses input CSV.
             - Added logic to skip Graph lookups on connection failure and report at end.
             - Includes custom Get-Gplink function & enhanced Graph connection handling.

    CRITICAL: Requires RSAT: Group Policy Management Tools feature installed.
    Requires discovery CSVs in InputCsvPath.
    Requires appropriate permissions for AD, GPO, and Microsoft Graph.
#>
param(
    [Parameter(Mandatory=$false)]
    [string]$InputCsvPath = "C:\DiscoveryData",

    [Parameter(Mandatory=$true)]
    [string]$OutputCsvPath,

    [Parameter(Mandatory=$true)]
    [string]$ClientId,

    [Parameter(Mandatory=$true)]
    [string]$ClientSecret,

    [Parameter(Mandatory=$true)]
    [string]$TenantId,

    [Parameter(Mandatory=$false)]
    [ValidateSet('UserPrincipalName', 'SamAccountName')]
    [string]$UserIdentifierProperty = 'UserPrincipalName',

    [Parameter(Mandatory=$false)]
    [string]$DomainController = "ad.zedra.com",

    [Parameter(Mandatory=$false)]
    [int]$BatchSize = 100
)

#region Global Settings & Setup
$ErrorActionPreference = "Stop"
$VerbosePreference = "Continue"

$script:GraphConnectionFailed = $false
$script:StateFilePath = Join-Path $OutputCsvPath "aggregation_progress.state"

function Write-Log {
    param(
        [Parameter(Mandatory=$true)]
        [string]$Message,
        [Parameter(Mandatory=$false)]
        [ValidateSet("INFO", "WARN", "ERROR")]
        [string]$Level = "INFO"
    )
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $cleanedMessage = $Message -replace "[\r\n]+", " "
    $LogMessage = "[$timestamp] [$Level] $cleanedMessage"
    switch ($Level) {
        "INFO" { Write-Host $LogMessage -ForegroundColor Green }
        "WARN" { Write-Host $LogMessage -ForegroundColor Yellow }
        "ERROR" { Write-Host $LogMessage -ForegroundColor Red }
    }
    Write-Verbose $LogMessage
    if ($script:LogPath -and (Test-Path $script:LogDir -PathType Container)) {
        try {
            Add-Content -Path $script:LogPath -Value $LogMessage -Encoding UTF8 -ErrorAction Stop
        } catch {
            Write-Warning "Failed to write to log file '$($script:LogPath)': $($_.Exception.Message)"
        }
    }
}

$script:requiredModules = @(
    @{ Name = "ActiveDirectory"; Version = $null; Installable = $false; Notes = "Requires RSAT: AD DS Tools feature." },
    @{ Name = "GroupPolicy"; Version = $null; Installable = $false; Notes = "Requires RSAT: Group Policy Management feature." },
    @{ Name = "Microsoft.Graph"; Version = $null; Installable = $true; Notes = "Needed for Intune/App Assignment lookups." },
    @{ Name = "Microsoft.Graph.Groups"; Version = $null; Installable = $true; Notes = "Needed for Group Membership resolution." },
    @{ Name = "Microsoft.Graph.Users"; Version = $null; Installable = $true; Notes = "Needed for User lookups." },
    @{ Name = "Microsoft.Graph.Applications"; Version = $null; Installable = $true; Notes = "Needed for App/SP lookups." },
    @{ Name = "Microsoft.Graph.DeviceManagement"; Version = $null; Installable = $true; Notes = "Needed for Intune Assignment lookups." }
)

$script:graphScopes = @(
    "Directory.Read.All", "GroupMember.Read.All", "User.Read.All", "Policy.Read.All",
    "DeviceManagementConfiguration.Read.All", "AppRoleAssignment.Read.All", "Application.Read.All"
)

$script:LogDir = Join-Path $OutputCsvPath "Logs"
$script:LogPath = Join-Path $script:LogDir "AggregationRun_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"

if (-not (Test-Path $OutputCsvPath -PathType Container)) {
    Write-Verbose "Creating output directory: $OutputCsvPath"
    try {
        New-Item -Path $OutputCsvPath -ItemType Directory -Force -ErrorAction Stop | Out-Null
    } catch {
        Write-Error "Failed to create output directory '$OutputCsvPath'. Error: $($_.Exception.Message)"; exit 1
    }
}

if (-not (Test-Path $script:LogDir -PathType Container)) {
    Write-Verbose "Creating log directory: $($script:LogDir)"
    try {
        New-Item -Path $script:LogDir -ItemType Directory -Force -ErrorAction Stop | Out-Null
    } catch {
        Write-Warning "Failed to create log directory '$($script:LogDir)'. Logging to file disabled."
        $script:LogPath = $null
    }
}

if ([string]::IsNullOrWhiteSpace($DomainController)) {
    Write-Log "ERROR: Domain Controller name is missing or invalid." -Level ERROR; exit 1
}
Write-Log "Using Domain Controller: $($DomainController)" -Level INFO
Write-Log "Batch Size: $($BatchSize)" -Level INFO
Write-Log "State File: $($script:StateFilePath)" -Level INFO

#endregion Global Settings & Setup

#region Core Functions
function Check-RequiredModules {
    Write-Log "Checking required PowerShell modules for aggregation..."
    $missingModules = @()

    foreach ($moduleInfo in $script:requiredModules) {
        $moduleName = $moduleInfo.Name
        $requiredVersion = $moduleInfo.Version
        $isInstallable = $moduleInfo.Installable
        $notes = $moduleInfo.Notes
        Write-Verbose "Checking for module: $moduleName"

        $installedModule = Get-Module -Name $moduleName -ListAvailable
        if (-not $installedModule) {
            Write-Verbose "Module $moduleName not found."
            $missingModules += $moduleInfo
        } elseif ($requiredVersion) {
            $versionMatch = $installedModule | Where-Object { $_.Version -eq $requiredVersion }
            if (-not $versionMatch) {
                Write-Verbose "Module $($moduleName) found, but required version $($requiredVersion) not installed. Found: $($installedModule.Version -join ', ')"
                $missingModules += $moduleInfo
            }
        } else {
            Write-Verbose "Module $($moduleName) found (any version acceptable)."
            if ($moduleName -eq "ActiveDirectory") {
                try {
                    Import-Module ActiveDirectory -ErrorAction Stop
                    Get-ADDomain -ErrorAction Stop | Out-Null
                    Write-Verbose "ActiveDirectory module is functional."
                } catch {
                    Write-Log "ActiveDirectory module loaded but not functional: $($_.Exception.Message)" -Level WARN
                    $missingModules += $moduleInfo
                }
            }
        }
    }

    if ($missingModules.Count -gt 0) {
        Write-Log "Missing or non-functional required modules:" -Level WARN
        $nonInstallableMissing = @()

        foreach ($missing in $missingModules) {
            $versionInfo = if ($missing.Version) { "version $($missing.Version)" } else { "" }
            if ($missing.Installable) {
                Write-Log "ERROR: Installable module $($missing.Name) $($versionInfo) is missing. Please install manually." -Level ERROR
                $nonInstallableMissing += $missing
            } else {
                Write-Log "- $($missing.Name) $($versionInfo) (Not Installable via PSGallery. $($missing.Notes))" -Level WARN
                $nonInstallableMissing += $missing
            }
        }

        if ($nonInstallableMissing.Count -gt 0) {
            Write-Log "Cannot proceed without missing or non-functional modules. Please ensure RSAT features or required modules are installed." -Level ERROR
            exit 1
        }
    } else {
        Write-Log "All required modules are available and functional."
    }
}

function Connect-GraphAggregator {
    Write-Log "Checking Microsoft Graph connection for aggregation tasks..."
    $forceReconnect = $false

    try {
        $graphContext = Get-MgContext -ErrorAction SilentlyContinue
        if ($graphContext -and $graphContext.Account) {
            Write-Log "Existing Graph connection found for ClientId $($graphContext.ClientId)."
            $tokenScopes = $graphContext.Scopes -split ' '
            $missingScopes = $script:graphScopes | Where-Object { $_ -notin $tokenScopes }
            if ($missingScopes) {
                Write-Log "Current Graph connection missing required scopes: $($missingScopes -join ', ')" -Level WARN
                $forceReconnect = $true
            } else {
                try {
                    Get-MgContext -ErrorAction Stop | Out-Null
                    Write-Log "Existing Graph token appears valid."
                    return $true
                } catch {
                    Write-Log "Existing Graph token failed validity test: $($_.Exception.Message)" -Level WARN
                    $forceReconnect = $true
                }
            }
        } else {
            Write-Log "No existing Graph connection found."
            $forceReconnect = $true
        }
    } catch {
        Write-Log "Error checking existing Graph context: $($_.Exception.Message)" -Level WARN
        $forceReconnect = $true
    }

    if ($forceReconnect) {
        Write-Log "Attempting to disconnect any previous context and reconnect..."
        Disconnect-MgGraph -ErrorAction SilentlyContinue
        Write-Log "Connecting to Microsoft Graph using client credentials..."
        try {
            $secureSecret = ConvertTo-SecureString $ClientSecret -AsPlainText -Force
            $clientSecretCredential = New-Object System.Management.Automation.PSCredential ($ClientId, $secureSecret)
            Connect-MgGraph -ClientSecretCredential $clientSecretCredential -TenantId $TenantId -ErrorAction Stop
            $newContext = Get-MgContext -ErrorAction Stop
            Write-Log "Successfully connected to Microsoft Graph with ClientId $($newContext.ClientId)."
            return $true
        } catch {
            Write-Log "Graph connection failed: $($_.Exception.Message)" -Level ERROR
            return $false
        }
    }
    return $true
}

function Ensure-AggregatorConnections {
    Write-Log "Ensuring connections (Graph only check)..."
    if (-not (Connect-GraphAggregator)) {
        Write-Log "Graph connection failed. Graph-dependent data will be skipped." -Level WARN
        $script:GraphConnectionFailed = $true
    } else {
        Write-Log "Graph connection successful or already established." -Level INFO
        $script:GraphConnectionFailed = $false
    }
}

function Import-InputCsv {
    param(
        [Parameter(Mandatory=$true)]
        [string]$FileName
    )
    $filePath = Join-Path $InputCsvPath "$($FileName).csv"
    if (Test-Path $filePath -PathType Leaf) {
        Write-Log "Loading input file: $($filePath)"
        try {
            return Import-Csv -Path $filePath -Encoding UTF8 -ErrorAction Stop
        } catch {
            Write-Log "Error loading CSV '$($filePath)': $($_.Exception.Message)" -Level ERROR
            return $null
        }
    } else {
        Write-Log "Input file not found: '$($filePath)'" -Level WARN
        return $null
    }
}

function Append-BatchToCsvs {
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$BatchData
    )
    Write-Log "Appending batch data to CSV files..." -Level INFO
    foreach ($item in $BatchData.GetEnumerator()) {
        $fileNameBase = $item.Name
        $dataList = $item.Value
        $filePath = Join-Path $OutputCsvPath "$($fileNameBase).csv"
        Write-Verbose "Processing output for '$fileNameBase' with $($dataList.Count) records"
        if ($dataList -and $dataList.Count -gt 0) {
            try {
                $fileExists = Test-Path $filePath -PathType Leaf
                if (-not $fileExists) {
                    Write-Log "Creating new CSV file: $filePath" -Level INFO
                    $dataList | Export-Csv -Path $filePath -NoTypeInformation -Encoding UTF8 -ErrorAction Stop
                    Write-Log "Successfully created and wrote $($dataList.Count) records to '$filePath'" -Level INFO
                } else {
                    Write-Log "Appending $($dataList.Count) records to existing CSV: $filePath" -Level INFO
                    $dataList | Export-Csv -Path $filePath -NoTypeInformation -Encoding UTF8 -Append -ErrorAction Stop
                    Write-Log "Successfully appended records to '$filePath'" -Level INFO
                }
            } catch {
                Write-Log "Error writing to CSV '$filePath': $($_.Exception.Message)" -Level ERROR
            }
        } else {
            Write-Log "No data to write for '$fileNameBase'. Skipping CSV output." -Level INFO
        }
    }
    Write-Log "Finished appending batch data." -Level INFO
}

function Get-Gplink {
    [cmdletBinding()]
    param (
        [string]$path,
        [string]$server,
        [string]$site
    )
    $configpart = (Get-ADRootDSE -ErrorAction SilentlyContinue).configurationNamingContext
    if (-not $configpart) {
        Write-Log "Get-Gplink: Could not get Configuration Naming Context from RootDSE." -Level WARN
        return $null
    }
    $gplinkObject = $null
    $target = $null
    try {
        if ($site) {
            $gplinkObject = Get-ADObject -Filter { distinguishedname -eq $site } -SearchBase $configpart -Properties gplink -Server $server -ErrorAction Stop
            $target = $site
        } elseif ($path) {
            $gplinkObject = Get-ADObject -Filter { distinguishedname -eq $path } -Properties gplink -Server $server -ErrorAction Stop
            $target = $path
        }
    } catch {
        Write-Log "Get-Gplink: Error getting AD object '$($path)$($site)' on server '$server': $($_.Exception.Message)" -Level WARN
        return $null
    }
    if ($gplinkObject -eq $null -or -not $gplinkObject.PSObject.Properties['gplink']) {
        return $null
    }
    if ($gplinkObject.gplink -and $gplinkObject.gplink.Trim().Length -gt 0) {
        $linkOrder = 0
        $results = [System.Collections.Generic.List[PSCustomObject]]::new()
        $splitLinks = $gplinkObject.gplink.split("]")
        for ($s = $splitLinks.count - 1; $s -gt -1; $s--) {
            if ($splitLinks[$s].length -gt 0) {
                $linkOrder++
                $gpoGuid = $null
                $domainName = $null
                try {
                    $linkData = $splitLinks[$s].TrimStart('[')
                    $parts = $linkData -split ';'
                    $ldapPath = $parts[0]
                    $options = $parts[1]
                    if ($ldapPath -like 'LDAP://*') {
                        $dnPart = $ldapPath -replace 'LDAP://CN=\{', '' -replace '\},CN=Policies,CN=System,', ''
                        if ($dnPart -match '^([0-9A-F]{8}-([0-9A-F]{4}-){3}[0-9A-F]{12})(.*)$') {
                            $gpoGuid = $Matches[1]
                            $domainDN = $Matches[3].TrimStart(',')
                            $domainName = $domainDN.replace("DC=", "").replace(",", ".")
                        } else {
                            Write-Log "Get-Gplink: Could not extract GUID from link: $($ldapPath)" -Level WARN
                            continue
                        }
                    } else {
                        Write-Log "Get-Gplink: Unexpected format in link: $($ldapPath)" -Level WARN
                        continue
                    }
                    $isEnabled = "No"
                    $isEnforced = "No"
                    if ($options -eq '0') { $isEnabled = "Yes"; $isEnforced = "No" }
                    elseif ($options -eq '1') { $isEnabled = "No"; $isEnforced = "No" }
                    elseif ($options -eq '2') { $isEnabled = "Yes"; $isEnforced = "Yes" }
                    elseif ($options -eq '3') { $isEnabled = "No"; $isEnforced = "Yes" }
                    $gpoDisplayName = "Orphaned GPLink"
                    $checkDC = $null
                    if ($domainName) {
                        $checkDC = (Get-ADDomainController -DomainName $domainName -Discover -ErrorAction SilentlyContinue).Name
                    }
                    if ($checkDC -and (Get-Command Get-GPO -ErrorAction SilentlyContinue)) {
                        $mygpo = Get-GPO -Guid $gpoGuid -Domain $domainName -Server $checkDC -ErrorAction SilentlyContinue
                        if ($mygpo) { $gpoDisplayName = $mygpo.DisplayName }
                    }
                    $returnObject = [PSCustomObject]@{
                        Target      = $target
                        GPOID       = $gpoGuid
                        DisplayName = $gpoDisplayName
                        Domain      = $domainName
                        Enforced    = $isEnforced
                        Enabled     = $isEnabled
                        Order       = $linkOrder
                    }
                    $results.Add($returnObject)
                } catch {
                    Write-Log "Get-Gplink: Error parsing link '$($splitLinks[$s])': $($_.Exception.Message)" -Level WARN
                    continue
                }
            }
        }
        return $results
    }
    return $null
}

function Get-AppliedGPOsForUser {
    param(
        [Parameter(Mandatory = $true)] [PSCustomObject]$User,
        [Parameter(Mandatory = $true)] [hashtable]$UserGroupMembershipSids,
        [Parameter(Mandatory = $true)] [hashtable]$GpoPermissionsCache,
        [Parameter(Mandatory = $true)] [hashtable]$GpoLinkCache
    )
    Write-Verbose "Processing GPOs for user '$($User.SamAccountName)' with SID '$($User.SID)'"
    $appliedGpos = [System.Collections.Generic.List[PSCustomObject]]::new()
    $userSid = $User.SID
    if (-not $userSid -or -not ($userSid -is [string]) -or $userSid.Length -lt 5) {
        Write-Log "Cannot determine GPO application for $($User.$UserIdentifierProperty) (SAM: $($User.SamAccountName)) without a valid user SID string." -Level WARN
        return $appliedGpos
    }
    $userGroupsSids = if ($UserGroupMembershipSids.ContainsKey($User.SamAccountName)) { $UserGroupMembershipSids[$User.SamAccountName] } else { @() }
    $ouPath = $User.DistinguishedName -replace '^CN=.*?,(OU=.*)$', '$1' -replace '^CN=.*?,(CN=(Users|Computers).*)$', '$1'
    $ouHierarchy = @()
    $currentOu = $ouPath
    $domainDN = if ($User.DistinguishedName -match 'DC=.*') { ($User.DistinguishedName -split '(DC=.*)', 2)[1] } else { $null }
    if (-not $domainDN) {
        Write-Log "Could not determine domain DN from user DN for $($User.$UserIdentifierProperty) (DN: $($User.DistinguishedName))" -Level WARN
        return $appliedGpos
    }
    while ($currentOu -ne $domainDN -and $currentOu -match '(OU=|CN=)') {
        $ouHierarchy += $currentOu
        $parentOu = $currentOu -replace '^(OU|CN)=.*?,(.*)$', '$2'
        if ($parentOu -eq $currentOu -or -not $parentOu) { break }
        $currentOu = $parentOu
    }
    $ouHierarchy += $domainDN
    $ouHierarchy = $ouHierarchy | Select-Object -Unique
    $processedGpoIds = [System.Collections.Generic.HashSet[string]]::new([System.StringComparer]::OrdinalIgnoreCase)
    foreach ($ouDN in $ouHierarchy) {
        try {
            if (-not $gpoLinkCache.ContainsKey($ouDN)) {
                Write-Verbose "Querying GPO links for OU/Domain: $($ouDN)"
                if ([string]::IsNullOrWhiteSpace($script:SelectedDomainController)) { 
                    Write-Log "Domain Controller missing for GPO link query on '$ouDN' for user $($User.$UserIdentifierProperty)" -Level WARN
                    continue
                }
                $gpoLinkCache[$ouDN] = Get-Gplink -path $ouDN -server $script:SelectedDomainController
            }
            $links = $gpoLinkCache[$ouDN]
            if ($links -eq $null -or $links.Count -eq 0) {
                Write-Verbose "No GPO links found for OU/Domain: $($ouDN)"
                continue
            }
            foreach ($link in $links) {
                $gpoId = $link.GPOID
                if (-not $gpoId -or $gpoId.Length -ne 36) {
                    Write-Log "Skipping link on '$ouDN' due to invalid GPOID: '$($gpoId)' for user $($User.$UserIdentifierProperty)" -Level WARN
                    continue
                }
                $gpoName = $link.DisplayName
                $isEnforced = ($link.Enforced -eq 'Yes')
                $isEnabled = ($link.Enabled -eq 'Yes')
                if (-not $isEnabled) {
                    Write-Verbose "Skipping disabled GPO link: $($gpoName) on $ouDN"
                    continue
                }
                if ($processedGpoIds.Contains($gpoId) -and !$isEnforced) {
                    Write-Verbose "Skipping GPO '$($gpoName)' linked at '$($ouDN)' as it was already processed."
                    continue
                }
                if (-not $GpoPermissionsCache.ContainsKey($gpoId)) {
                    Write-Verbose "Querying permissions for GPO: $($gpoName) ($($gpoId))"
                    if ([string]::IsNullOrWhiteSpace($script:SelectedDomainController)) { 
                        Write-Log "Domain Controller missing for GPO permission query on '$gpoName' ($gpoId) for user $($User.$UserIdentifierProperty)" -Level WARN
                        continue
                    }
                    if (Get-Command Get-GPPermission -ErrorAction SilentlyContinue) {
                        try {
                            $GpoPermissionsCache[$gpoId] = Get-GPPermission -Guid $gpoId -All -Server $script:SelectedDomainController -ErrorAction Stop
                        } catch {
                            Write-Log "Failed to retrieve permissions for GPO '$gpoName' ($gpoId) for user $($User.$UserIdentifierProperty): $($_.Exception.Message)" -Level WARN
                            $GpoPermissionsCache[$gpoId] = $null
                        }
                    } else {
                        Write-Log "Get-GPPermission command not found for GPO '$gpoName' ($gpoId) for user $($User.$UserIdentifierProperty)." -Level WARN
                        $GpoPermissionsCache[$gpoId] = $null
                    }
                }
                $permissions = $GpoPermissionsCache[$gpoId]
                if ($permissions) {
                    $denyACEs = $permissions | Where-Object { $_.Type -eq 'Deny' -and $_.Permission -eq 'GpoApply' }
                    $isDenied = $false
                    foreach ($ace in $denyACEs) {
                        if ($ace.Trustee.Sid.Value -eq $userSid -or ($userGroupsSids -contains $ace.Trustee.Sid.Value)) {
                            $isDenied = $true
                            break
                        }
                    }
                    if (-not $isDenied) {
                        $allowACEs = $permissions | Where-Object { $_.Type -eq 'Allow' -and $_.Permission -eq 'GpoApply' }
                        $explicitAllow = $false
                        $groupAllows = $false
                        foreach ($ace in $allowACEs) {
                            if ($ace.Trustee.Sid.Value -eq $userSid) { $explicitAllow = $true }
                            if ($userGroupsSids -contains $ace.Trustee.Sid.Value) { $groupAllows = $true }
                        }
                        $authUsersApply = $allowACEs | Where-Object { $_.Trustee.Sid.Value -eq "S-1-5-11" }
                        if ($authUsersApply -or $explicitAllow -or $groupAllows) {
                            $appliedGpos.Add([PSCustomObject]@{
                                UserIdentifier     = $User.$UserIdentifierProperty
                                GpoName            = $gpoName
                                GpoId              = $gpoId
                                Link_Target_DN     = $ouDN
                                Link_Order         = $link.Order
                                IsSecurityFiltered = $true
                                IsEnforced         = $isEnforced
                            })
                            Write-Verbose "Applied GPO '$gpoName' ($gpoId) to user $($User.$UserIdentifierProperty)"
                            if (!$isEnforced) { $processedGpoIds.Add($gpoId) | Out-Null }
                        } else {
                            Write-Verbose "GPO '$gpoName' skipped for user '$($User.$UserIdentifierProperty)' due to security filtering."
                            if (!$isEnforced) { $processedGpoIds.Add($gpoId) | Out-Null }
                        }
                    } elseif ($isDenied) {
                        Write-Verbose "GPO '$gpoName' skipped for user '$($User.$UserIdentifierProperty)' due to explicit Deny ACE."
                        if (!$isEnforced) { $processedGpoIds.Add($gpoId) | Out-Null }
                    }
                } else {
                    Write-Log "Could not retrieve permissions for GPO '$gpoName' ($gpoId) for user $($User.$UserIdentifierProperty). Assuming applies." -Level WARN
                    $appliedGpos.Add([PSCustomObject]@{
                        UserIdentifier     = $User.$UserIdentifierProperty
                        GpoName            = $gpoName
                        GpoId              = $gpoId
                        Link_Target_DN     = $ouDN
                        Link_Order         = $link.Order
                        IsSecurityFiltered = $false
                        IsEnforced         = $isEnforced
                    })
                    Write-Verbose "Applied GPO '$gpoName' ($gpoId) to user $($User.$UserIdentifierProperty) (no permissions data)"
                    if (!$isEnforced) { $processedGpoIds.Add($gpoId) | Out-Null }
                }
            }
        } catch {
            Write-Log "Error processing GPO links for target '$ouDN' for user $($User.$UserIdentifierProperty): $($_.Exception.Message)" -Level WARN
            continue
        }
        if ($ouDN -like 'OU=*') {
            try {
                if ([string]::IsNullOrWhiteSpace($script:SelectedDomainController)) { 
                    Write-Log "Domain Controller missing for OU inheritance check on '$ouDN' for user $($User.$UserIdentifierProperty)" -Level WARN
                    continue
                }
                $ouObject = Get-ADOrganizationalUnit -Identity $ouDN -Properties Options -Server $script:SelectedDomainController -ErrorAction SilentlyContinue
                if ($ouObject -and ($ouObject.Options -band 1)) {
                    Write-Verbose "Inheritance blocked at OU: $($ouDN) for user $($User.$UserIdentifierProperty)"
                    break
                }
            } catch {
                Write-Log "Could not check inheritance blocking for OU '$ouDN' for user $($User.$UserIdentifierProperty): $($_.Exception.Message)" -Level WARN
            }
        }
    }
    Write-Verbose "Completed GPO processing for user '$($User.SamAccountName)'. Applied $($appliedGpos.Count) GPOs."
    return $appliedGpos
}

function Get-GraphTransitiveGroupMembers {
    param(
        [string]$GroupId
    )
    if ([string]::IsNullOrWhiteSpace($GroupId)) { return @() }
    if ($script:GraphGroupMembershipCache.ContainsKey($GroupId)) {
        return $script:GraphGroupMembershipCache[$GroupId]
    }
    Write-Verbose "Querying Graph for transitive members of group $($GroupId)"
    try {
        $allMembers = Get-MgGroupTransitiveMember -GroupId $GroupId -All -ErrorAction Stop | Where-Object { $_.'@odata.type' -eq '#microsoft.graph.user' }
        $memberUPNs = $allMembers | ForEach-Object { $_.AdditionalProperties.userPrincipalName } | Where-Object { -not [string]::IsNullOrWhiteSpace($_) } | Select-Object -Unique
        Write-Verbose "Found $($memberUPNs.Count) transitive user members for group $($GroupId)"
        $script:GraphGroupMembershipCache[$GroupId] = $memberUPNs
        return $memberUPNs
    } catch {
        Write-Log "Error getting transitive members for Graph group $($GroupId): $($_.Exception.Message)" -Level WARN
        $script:GraphGroupMembershipCache[$GroupId] = @()
        return @()
    }
}

#endregion Core Functions

#region Main Aggregation Logic
Write-Log "=========================================================="
Write-Log " Starting User-Centric Data Aggregation (v2.10.12 - Service Principal Auth, Fixed TypeNotFound) "
Write-Log " Input Path: $($InputCsvPath)"
Write-Log " Output Path: $($OutputCsvPath)"
Write-Log " User Identifier: $($UserIdentifierProperty)"
Write-Log " Domain Controller: $($DomainController)"
Write-Log " Batch Size: $($BatchSize)"
Write-Log "=========================================================="

Write-Log "Starting Preprocessing..." -Level INFO
Check-RequiredModules
if (-not (Test-Path $InputCsvPath -PathType Container)) {
    Write-Log "Input CSV path not found: '$($InputCsvPath)'." -Level ERROR
    exit 1
}
try {
    Write-Log "Attempting to import GroupPolicy module..."
    Import-Module GroupPolicy -ErrorAction Stop
    if (-not (Get-Command Get-GPPermission -ErrorAction SilentlyContinue)) {
        Write-Log "ERROR: Get-GPPermission command not found." -Level ERROR
        exit 1
    }
} catch {
    Write-Log "Failed to import GroupPolicy module: $($_.Exception.Message)" -Level ERROR
    exit 1
}
Ensure-AggregatorConnections
Write-Log "Loading input CSV data from $($InputCsvPath)..."
$adUsersDataAll = Import-InputCsv -FileName "ADUsers"
$secGroupData = Import-InputCsv -FileName "SecurityGroups"
$secGroupMemberData = Import-InputCsv -FileName "SecurityGroupMembers"
$dlData = Import-InputCsv -FileName "DistributionLists"
$sharedMbData = Import-InputCsv -FileName "SharedMailboxes"
$mailboxesData = Import-InputCsv -FileName "Mailboxes"
$gpoData = Import-InputCsv -FileName "GroupPolicies"
$driveMapData = Import-InputCsv -FileName "DriveMappingsGPO"
$logonScriptData = Import-InputCsv -FileName "LogonScripts"
$folderRedirData = Import-InputCsv -FileName "FolderRedirectionGPO"
$printerMapData = Import-InputCsv -FileName "PrinterMappingsGPO"
$intunePolicyData = Import-InputCsv -FileName "IntuneDeviceConfigurationPolicies"
$entAppData = Import-InputCsv -FileName "EnterpriseApplications"
$appProxyData = Import-InputCsv -FileName "ApplicationProxies"
$oneDriveUsageData = Import-InputCsv -FileName "OneDriveUsage"
$teamsData = Import-InputCsv -FileName "UserTeamMemberships"
$licensingData = Import-InputCsv -FileName "UserLicenses"
$deviceInventoryData = Import-InputCsv -FileName "DeviceInventory"
$caPolicyData = Import-InputCsv -FileName "ConditionalAccessPolicies"
$caAssignmentData = Import-InputCsv -FileName "ConditionalAccessPolicyAssignments"
if (-not $adUsersDataAll) {
    Write-Log "Cannot proceed without AD Users data." -Level ERROR
    exit 1
}
if (-not $sharedMbData) {
    Write-Log "Warning: SharedMailboxes.csv not found or failed to load." -Level WARN
}
Write-Log "Creating lookup tables..." -Level INFO
$adUsersHash = $adUsersDataAll | Where-Object { $_ -ne $null -and -not [string]::IsNullOrWhiteSpace($_.$UserIdentifierProperty) } | Group-Object -Property $UserIdentifierProperty -AsHashTable -AsString
$adUsersBySAM = $adUsersDataAll | Where-Object { $_ -ne $null -and -not [string]::IsNullOrWhiteSpace($_.SamAccountName) } | Group-Object -Property SamAccountName -AsHashTable -AsString
$adUsersByDN = $adUsersDataAll | Where-Object { $_ -ne $null -and -not [string]::IsNullOrWhiteSpace($_.DistinguishedName) } | Group-Object -Property DistinguishedName -AsHashTable -AsString
$adUsersByUPN = $adUsersDataAll | Where-Object { $_ -ne $null -and -not [string]::IsNullOrWhiteSpace($_.UserPrincipalName) } | Group-Object -Property UserPrincipalName -AsHashTable -AsString
$secGroupsHash = $secGroupData | Where-Object { $_ -ne $null -and -not [string]::IsNullOrWhiteSpace($_.SamAccountName) } | Group-Object -Property SamAccountName -AsHashTable -AsString
$gpoHash = $gpoData | Where-Object { $_ -ne $null } | ForEach-Object { $_.Id = $_.Id.ToString(); $_ } | Group-Object -Property Id -AsHashTable -AsString
$intunePolicyHash = $intunePolicyData | Where-Object { $_ -ne $null } | Group-Object -Property PolicyId -AsHashTable -AsString
$entAppHash = $entAppData | Where-Object { $_ -ne $null -and -not [string]::IsNullOrWhiteSpace($_.AppId) } | Group-Object -Property AppId -AsHashTable -AsString
$oneDriveUsageHash = $oneDriveUsageData | Where-Object { $_ -ne $null -and -not [string]::IsNullOrWhiteSpace($_.UserPrincipalName) } | Group-Object -Property UserPrincipalName -AsHashTable -AsString
$caPolicyHash = $caPolicyData | Where-Object { $_ -ne $null } | Group-Object -Property Id -AsHashTable -AsString
Write-Log "Preprocessing Group Memberships and SIDs..." -Level INFO
$validSecGroupMemberData = $secGroupMemberData | Where-Object { $_ -ne $null -and -not([string]::IsNullOrWhiteSpace($_.MemberSamAccountName)) -and -not([string]::IsNullOrWhiteSpace($_.GroupSamAccountName)) -and -not([string]::IsNullOrWhiteSpace($_.GroupDN)) }
$userGroupMembershipsAD_Groups = $validSecGroupMemberData | Group-Object -Property MemberSamAccountName -AsHashTable -AsString
$userGroupMembershipsAD = @{}
if ($userGroupMembershipsAD_Groups) {
    foreach ($groupEntry in $userGroupMembershipsAD_Groups.GetEnumerator()) {
        $userSAM = $groupEntry.Name
        $groupList = $groupEntry.Value
        $groupDNs = $groupList | ForEach-Object {
            if ($secGroupsHash.ContainsKey($_.GroupSamAccountName)) {
                $secGroupsHash[$_.GroupSamAccountName][0].DistinguishedName
            } else {
                Write-Log "Group SAM '$($_.GroupSamAccountName)' not found in SecurityGroups data for user '$($userSAM)'." -Level WARN
                $null
            }
        } | Where-Object { -not [string]::IsNullOrWhiteSpace($_) } | Select-Object -Unique
        if ($groupDNs) {
            $userGroupMembershipsAD[$userSAM] = $groupDNs
        }
    }
}
Write-Log "Fetching AD Group SIDs for GPO filtering..." -Level INFO
$groupSidCache = @{}
$allGroupDNsInMemberships = $validSecGroupMemberData | Select-Object -ExpandProperty GroupDN -Unique | Where-Object { -not [string]::IsNullOrWhiteSpace($_) }
$i_grp = 0
$totalGroupsToQuery = $allGroupDNsInMemberships.Count
Write-Log "Querying SIDs for $($totalGroupsToQuery) unique groups..."
foreach ($groupDN in $allGroupDNsInMemberships) {
    $i_grp++
    Write-Progress -Activity "Fetching Group SIDs" -Status "Processing group $($i_grp) of $($totalGroupsToQuery)" -PercentComplete (($i_grp / $totalGroupsToQuery) * 100)
    try {
        $group = Get-ADGroup -Identity $groupDN -Properties SID -Server $DomainController -ErrorAction Stop
        $groupSidCache[$groupDN] = $group.SID.Value
    } catch {
        Write-Log "Could not get SID for group '$($groupDN)': $($_.Exception.Message)" -Level WARN
    }
}
Write-Progress -Activity "Fetching Group SIDs" -Completed
$userGroupSidsAD = @{}
foreach ($userSAM in ($userGroupMembershipsAD.Keys | Where-Object { $_ })) {
    $groupDNs = $userGroupMembershipsAD[$userSAM] | Where-Object { $_ }
    $sids = $groupDNs | ForEach-Object { $groupSidCache[$_] } | Where-Object { $_ }
    if ($sids) {
        $userGroupSidsAD[$userSAM] = $sids
    }
}
Write-Log "Ensuring User SIDs are available..." -Level INFO
$userSidCache = @{}
$script:SelectedDomainController = $null
$maxRetries = 3
$retryDelaySeconds = 2
$sidRetrievalCount = 0
$sidMissingCount = 0
$adUsersDataAll | ForEach-Object {
    if (-not $_.PSObject.Properties['SID']) {
        $_ | Add-Member -MemberType NoteProperty -Name SID -Value $null -Force
    }
}
function Select-DomainController {
    param(
        [string]$PreferredDC,
        [int]$MaxRetries,
        [int]$RetryDelaySeconds
    )
    $dcCandidates = @()
    
    if (-not [string]::IsNullOrWhiteSpace($PreferredDC)) {
        Write-Verbose "Attempting to validate preferred Domain Controller: $PreferredDC"
        for ($retry = 1; $retry -le $MaxRetries; $retry++) {
            try {
                $dcInfo = Get-ADDomainController -Identity $PreferredDC -ErrorAction Stop
                Write-Log "Validated Domain Controller: $PreferredDC" -Level INFO
                return $dcInfo.Name
            } catch {
                Write-Log "Attempt $retry/$MaxRetries Failed to connect to Domain Controller '$PreferredDC': $($_.Exception.Message)" -Level WARN
                if ($retry -lt $MaxRetries) {
                    Start-Sleep -Seconds $RetryDelaySeconds
                }
            }
        }
    }
    
    Write-Log "Preferred Domain Controller unavailable. Attempting to discover an available Domain Controller..." -Level INFO
    for ($retry = 1; $retry -le $MaxRetries; $retry++) {
        try {
            $dcInfo = Get-ADDomainController -Discover -ForceDiscover -ErrorAction Stop
            if ($dcInfo) {
                Write-Log "Discovered Domain Controller: $($dcInfo.Name)" -Level INFO
                return $dcInfo.Name
            }
        } catch {
            Write-Log "Attempt $retry/$MaxRetries Failed to discover Domain Controller: $($_.Exception.Message)" -Level WARN
            if ($retry -lt $MaxRetries) {
                Start-Sleep -Seconds $RetryDelaySeconds
            }
        }
    }
    
    Write-Log "Discovery failed. Attempting to use default Domain Controller for current domain..." -Level WARN
    try {
        $domain = Get-ADDomain -ErrorAction Stop
        $defaultDC = $domain.PDCEmulator
        $dcInfo = Get-ADDomainController -Identity $defaultDC -ErrorAction Stop
        Write-Log "Using default Domain Controller: $defaultDC" -Level INFO
        return $dcInfo.Name
    } catch {
        Write-Log "Failed to retrieve default Domain Controller: $($_.Exception.Message)" -Level ERROR
        return $null
    }
}
$script:SelectedDomainController = Select-DomainController -PreferredDC $DomainController -MaxRetries $maxRetries -RetryDelaySeconds $retryDelaySeconds
if (-not $script:SelectedDomainController) {
    Write-Log "No Domain Controller could be reached after $maxRetries attempts. SID queries will be skipped." -Level WARN
    $script:ADConnectionFailed = $true
} else {
    Write-Log "Proceeding with Domain Controller: $script:SelectedDomainController" -Level INFO
    $script:ADConnectionFailed = $false
}
foreach ($userRow in $adUsersDataAll) {
    $userSamAccount = $userRow.SamAccountName
    if (-not $userSamAccount) {
        Write-Log "Skipping user record with missing SamAccountName (UPN: $($userRow.UserPrincipalName))" -Level WARN
        $userRow.SID = $null
        $userSidCache[$userSamAccount] = $null
        $sidMissingCount++
        continue
    }
    if ($userSamAccount.Length -gt 256 -or $userSamAccount -match '[\\/:*?"<>|]') {
        Write-Log "Invalid SamAccountName '$userSamAccount' (UPN: $($userRow.UserPrincipalName)). Contains illegal characters or exceeds 256 characters. Skipping SID query." -Level WARN
        $userRow.SID = $null
        $userSidCache[$userSamAccount] = $null
        $sidMissingCount++
        continue
    }
    $sidValue = $userRow.SID
    if (-not $sidValue -or ($sidValue -is [string] -and $sidValue.Length -lt 5) -or ($sidValue -is [System.Security.Principal.SecurityIdentifier] -and -not $sidValue.Value)) {
        if ($script:ADConnectionFailed) {
            Write-Log "Skipping SID query for user '$userSamAccount' (UPN: $($userRow.UserPrincipalName)) due to AD connection failure." -Level WARN
            $userRow.SID = $null
            $userSidCache[$userSamAccount] = $null
            $sidMissingCount++
            continue
        }
        try {
            Write-Verbose "Querying missing/invalid SID for user '$userSamAccount'"
            $userObj = Get-ADUser -Identity $userSamAccount -Properties SID -Server $script:SelectedDomainController -ErrorAction Stop
            if (-not $userObj.SID) {
                Write-Log "SID not returned for user '$userSamAccount' (UPN: $($userRow.UserPrincipalName))" -Level WARN
                $userRow.SID = $null
                $userSidCache[$userSamAccount] = $null
                $sidMissingCount++
                continue
            }
            $userSidValue = $userObj.SID.Value
            if (-not $userSidValue -or $userSidValue -notmatch '^S-1-') {
                Write-Log "Invalid SID format returned for user '$userSamAccount' (UPN: $($userRow.UserPrincipalName)): '$userSidValue'" -Level WARN
                $userRow.SID = $null
                $userSidCache[$userSamAccount] = $null
                $sidMissingCount++
                continue
            }
            $userRow.SID = $userSidValue
            $userSidCache[$userSamAccount] = $userSidValue
            $sidRetrievalCount++
            Write-Verbose "Retrieved SID '$userSidValue' for user '$userSamAccount'"
        } catch {
            $errorDetails = $_.Exception.Message
            $exceptionType = $_.Exception.GetType().FullName
            Write-Log "Failed to retrieve SID for user '$userSamAccount' (UPN: $($userRow.UserPrincipalName)): $errorDetails (Exception Type: $exceptionType)" -Level WARN
            if ($_.Exception.InnerException) {
                Write-Log "Inner Exception: $($_.Exception.InnerException.Message)" -Level WARN
            }
            $userRow.SID = $null
            $userSidCache[$userSamAccount] = $null
            $sidMissingCount++
        }
    } else {
        $userSidValue = if ($sidValue -is [System.Security.Principal.SecurityIdentifier]) { $sidValue.Value } else { $sidValue }
        if ($userSidValue -and $userSidValue -match '^S-1-') {
            $userRow.SID = $userSidValue
            $userSidCache[$userSamAccount] = $userSidValue
            $sidRetrievalCount++
        } else {
            Write-Log "Invalid SID format in input data for user '$userSamAccount' (UPN: $($userRow.UserPrincipalName)): '$userSidValue'. Setting to null." -Level WARN
            $userRow.SID = $null
            $userSidCache[$userSamAccount] = $null
            $sidMissingCount++
        }
    }
}
Write-Log "SID Retrieval Summary: Successfully retrieved $sidRetrievalCount SIDs, $sidMissingCount users have missing or invalid SIDs." -Level INFO
$sidSample = $adUsersDataAll | Where-Object { $_.SID } | Select-Object -First 5 | ForEach-Object { "$($_.SamAccountName): $($_.SID)" }
Write-Log "Sample of SIDs in adUsersDataAll (up to 5): $($sidSample -join ', ')" -Level INFO
Write-Log "Completed SID retrieval. Proceeding to next preprocessing steps." -Level INFO
Write-Log "Preprocessing Shared Mailbox Permissions from CSV..." -Level INFO
$userToSharedMailboxPermsLookup = @{}
if ($sharedMbData) {
    $reqCols = @('PrimarySmtpAddress', 'Permissions', 'SendAs')
    $props = $sharedMbData | Select-Object -First 1 | Get-Member -MemberType NoteProperty | Select-Object -ExpandProperty Name
    $missingCols = $reqCols | Where-Object { $props -notcontains $_ }
    if ($missingCols) {
        Write-Log "Warning: SharedMailboxes.csv missing required columns: $($missingCols -join ', '). Skipping permission processing." -Level WARN
        $sharedMbData = $null
    } else {
        $i_smb_parse = 0; $totalSmb = $sharedMbData.Count
        foreach ($smb in $sharedMbData) {
            $i_smb_parse++; Write-Progress -Activity "Parsing Shared Mailbox Permissions from CSV" -Status "Processing mailbox $i_smb_parse of $totalSmb" -PercentComplete (($i_smb_parse / $totalSmb) * 100)
            $smbAddress = $smb.PrimarySmtpAddress
            if ([string]::IsNullOrWhiteSpace($smbAddress)) { continue }
            if (-not [string]::IsNullOrWhiteSpace($smb.Permissions) -and $smb.Permissions -ne "Not Queried" -and $smb.Permissions -ne "ERROR") {
                $fullAccessEntries = $smb.Permissions -split ';' | Where-Object { $_ -match ':' }
                foreach ($entry in $fullAccessEntries) {
                    $parts = $entry -split ':', 2
                    $grantee = $parts[0].Trim()
                    $rights = $parts[1].Trim()
                    if ([string]::IsNullOrWhiteSpace($grantee)) { continue }
                    if (-not $userToSharedMailboxPermsLookup.ContainsKey($grantee)) { $userToSharedMailboxPermsLookup[$grantee] = [System.Collections.Generic.List[PSCustomObject]]::new() }
                    $userToSharedMailboxPermsLookup[$grantee].Add([PSCustomObject]@{
                        SharedMailbox_PrimarySmtpAddress = $smbAddress
                        PermissionType                 = "FullAccess"
                        AccessRights                   = $rights
                        GrantedViaIdentifier           = $grantee
                    })
                }
            }
            if (-not [string]::IsNullOrWhiteSpace($smb.SendAs) -and $smb.SendAs -ne "Not Queried" -and $smb.SendAs -ne "ERROR") {
                $sendAsEntries = $smb.SendAs -split ';' | Where-Object { $_ -match ':' }
                foreach ($entry in $sendAsEntries) {
                    $grantee = ($entry -split ':', 2)[0].Trim()
                    if ([string]::IsNullOrWhiteSpace($grantee)) { continue }
                    if (-not $userToSharedMailboxPermsLookup.ContainsKey($grantee)) { $userToSharedMailboxPermsLookup[$grantee] = [System.Collections.Generic.List[PSCustomObject]]::new() }
                    if (-not ($userToSharedMailboxPermsLookup[$grantee] | Where-Object {$_.SharedMailbox_PrimarySmtpAddress -eq $smbAddress -and $_.PermissionType -eq "SendAs"})) {
                        $userToSharedMailboxPermsLookup[$grantee].Add([PSCustomObject]@{
                            SharedMailbox_PrimarySmtpAddress = $smbAddress
                            PermissionType                 = "SendAs"
                            AccessRights                   = "SendAs"
                            GrantedViaIdentifier           = $grantee
                        })
                    }
                }
            }
        }
        Write-Progress -Activity "Parsing Shared Mailbox Permissions from CSV" -Completed
    }
} else {
    Write-Log "Skipping Shared Mailbox permission preprocessing as SharedMailboxes.csv was not loaded." -Level WARN
}
Write-Log "Finished preprocessing Shared Mailbox Permissions from CSV." -Level INFO
Write-Log "Preprocessing Conditional Access Policy Assignments..." -Level INFO
$caAssignmentLookup = @{}
if ($caAssignmentData) {
    foreach ($assignment in $caAssignmentData) {
        $targetId = $assignment.TargetId
        $policyId = $assignment.PolicyId
        $assignmentType = $assignment.AssignmentType
        if ([string]::IsNullOrWhiteSpace($targetId)) { continue }
        if (-not $caAssignmentLookup.ContainsKey($targetId)) { $caAssignmentLookup[$targetId] = [System.Collections.Generic.List[PSCustomObject]]::new() }
        $caAssignmentLookup[$targetId].Add([PSCustomObject]@{
            PolicyId       = $policyId
            AssignmentType = $assignmentType
        })
    }
} else {
    Write-Log "No Conditional Access Assignment data found to preprocess." -Level WARN
}
Write-Log "Finished preprocessing Conditional Access Policy Assignments." -Level INFO
Write-Log "Preprocessing Finished Successfully." -Level INFO

try {
    if (-not $adUsersDataAll -or $adUsersDataAll.Count -eq 0) {
        Write-Log "Critical error: AD Users data is missing or empty." -Level ERROR
        exit 1
    }
    $totalUserCount = $adUsersDataAll.Count
    $processedUserCountTotal = 0
    $usersToProcess = $null
    $lastProcessedUserId = $null
    $startIndex = 0
    if (Test-Path $script:StateFilePath -PathType Leaf) {
        try {
            $lastProcessedUserId = Get-Content $script:StateFilePath -ErrorAction Stop
            Write-Log "Found state file. Last processed user: $($lastProcessedUserId)" -Level INFO
            $lastIndex = -1
            for ($idx = 0; $idx -lt $adUsersDataAll.Count; $idx++) {
                if ($adUsersDataAll[$idx].PSObject.Properties[$UserIdentifierProperty] -ne $null -and $adUsersDataAll[$idx].$UserIdentifierProperty -eq $lastProcessedUserId) {
                    $lastIndex = $idx
                    break
                }
            }
            if ($lastIndex -ge 0) {
                $startIndex = $lastIndex + 1
                if ($startIndex -ge $totalUserCount) {
                    Write-Log "All users were already processed according to state file." -Level INFO
                    $usersToProcess = [System.Collections.Generic.List[PSCustomObject]]::new()
                    $processedUserCountTotal = $totalUserCount
                } else {
                    $remainingUsersArray = $adUsersDataAll[$startIndex..($totalUserCount - 1)]
                    $usersToProcess = [System.Collections.Generic.List[PSCustomObject]]::new()
                    $usersToProcess.AddRange([PSCustomObject[]]$remainingUsersArray)
                    $processedUserCountTotal = $startIndex
                    if ($usersToProcess.Count -gt 0) {
                        Write-Log "Resuming from user #$($startIndex + 1) ($($usersToProcess[0].$UserIdentifierProperty)). $($usersToProcess.Count) users remaining." -Level INFO
                    } else {
                        Write-Log "Resuming processing, but remaining user list is empty." -Level WARN
                    }
                }
            } else {
                Write-Log "Last processed user '$($lastProcessedUserId)' not found. Processing all users." -Level WARN
                $usersToProcess = [System.Collections.Generic.List[PSCustomObject]]::new()
                $usersToProcess.AddRange([PSCustomObject[]]$adUsersDataAll)
            }
        } catch {
            Write-Log "Error reading state file '$($script:StateFilePath)': $($_.Exception.Message). Processing all users." -Level WARN
            $usersToProcess = [System.Collections.Generic.List[PSCustomObject]]::new()
            $usersToProcess.AddRange([PSCustomObject[]]$adUsersDataAll)
        }
    } else {
        Write-Log "No state file found. Processing all users." -Level INFO
        $usersToProcess = [System.Collections.Generic.List[PSCustomObject]]::new()
        $usersToProcess.AddRange([PSCustomObject[]]$adUsersDataAll)
    }
    if ($null -eq $usersToProcess) {
        Write-Log "Critical error: Failed to initialize \$usersToProcess list." -Level ERROR
        exit 1
    }
    $batchUsersCore = [System.Collections.Generic.List[PSCustomObject]]::new()
    $batchUserSecGroupMembership = [System.Collections.Generic.List[PSCustomObject]]::new()
    $batchUserDlMembership = [System.Collections.Generic.List[PSCustomObject]]::new()
    $batchUserSharedMbPerms = [System.Collections.Generic.List[PSCustomObject]]::new()
    $batchUserAppliedGpos = [System.Collections.Generic.List[PSCustomObject]]::new()
    $batchUserIntuneAssignments = [System.Collections.Generic.List[PSCustomObject]]::new()
    $batchUserAppAssignments = [System.Collections.Generic.List[PSCustomObject]]::new()
    $batchUserLogonScripts = [System.Collections.Generic.List[PSCustomObject]]::new()
    $batchUserDriveMaps = [System.Collections.Generic.List[PSCustomObject]]::new()
    $batchUserFolderRedir = [System.Collections.Generic.List[PSCustomObject]]::new()
    $batchUserPrinterMaps = [System.Collections.Generic.List[PSCustomObject]]::new()
    $batchUserTeamMembership = [System.Collections.Generic.List[PSCustomObject]]::new()
    $batchUserLicenseAssignments = [System.Collections.Generic.List[PSCustomObject]]::new()
    $batchUserDevices = [System.Collections.Generic.List[PSCustomObject]]::new()
    $batchUserCAPolicyAssignments = [System.Collections.Generic.List[PSCustomObject]]::new()
    $gpoPermissionsCache = @{}
    $gpoLinkCache = @{}
    $script:GraphGroupMembershipCache = @{}
    $graphUserIdCache = @{}
    $graphGroupDetailCache = @{}
    $graphRoleDetailCache = @{}
    Write-Log "Processing $($usersToProcess.Count) users..."
    $currentBatchUserCount = 0
    $lastUserProcessedInBatch = $null
    foreach ($user in $usersToProcess) {
        $processedUserCountTotal++
        $currentBatchUserCount++
        if (-not $user.$UserIdentifierProperty -or [string]::IsNullOrWhiteSpace($user.$UserIdentifierProperty) -or
            -not $user.SamAccountName -or [string]::IsNullOrWhiteSpace($user.SamAccountName)) {
            Write-Log "Skipping user record #$($processedUserCountTotal) due to missing identifiers." -Level WARN
            continue
        }
        $userId = $user.$UserIdentifierProperty
        $userSam = $user.SamAccountName
        $userUPN = $user.UserPrincipalName
        $userEmail = $user.mail
        $userDN = $user.DistinguishedName
        $userSID = $user.SID
        Write-Progress -Activity "Aggregating User Data" -Status "Processing user $processedUserCountTotal of $totalUserCount ($userId)" -PercentComplete (($processedUserCountTotal / $totalUserCount) * 100)
        Write-Verbose "Processing User: $userId (SAM: $userSam)"
        $userGraphId = $null
        if (-not $script:GraphConnectionFailed -and $userUPN -and -not [string]::IsNullOrWhiteSpace($userUPN)) {
            if ($graphUserIdCache.ContainsKey($userUPN)) {
                $userGraphId = $graphUserIdCache[$userUPN]
            } else {
                try {
                    Write-Verbose "Querying Graph ID for $userUPN"
                    $graphUser = Get-MgUser -UserId $userUPN -Property Id -ErrorAction Stop
                    $userGraphId = $graphUser.Id
                    $graphUserIdCache[$userUPN] = $userGraphId
                } catch {
                    $exceptionType = $_.Exception.GetType().FullName
                    $exceptionMessage = $_.Exception.Message
                    Write-Log "Error getting Graph ID for user '$userUPN'. Type: $exceptionType" -Level WARN
                    try { Write-Log "Error Message: $exceptionMessage" -Level WARN } catch { Write-Log "Failed to log error message: $($_.Exception.Message)" -Level ERROR }
                    if ($exceptionMessage -match 'Authentication needed' -or $exceptionMessage -match 'Token has expired') {
                        Write-Log "Attempting reconnect for user '$userUPN'..." -Level WARN
                        if (Ensure-AggregatorConnections) {
                            try {
                                $graphUser = Get-MgUser -UserId $userUPN -Property Id -ErrorAction Stop
                                $userGraphId = $graphUser.Id
                                $graphUserIdCache[$userUPN] = $userGraphId
                                Write-Log "Retrieved Graph ID after reconnect." -Level INFO
                            } catch {
                                Write-Log "Still could not get Graph ID after reconnect: $($_.Exception.Message)" -Level WARN
                                $graphUserIdCache[$userUPN] = $null
                            }
                        } else {
                            Write-Log "Reconnect failed." -Level ERROR
                            $graphUserIdCache[$userUPN] = $null
                        }
                    } elseif ($exceptionMessage -match 'Resource .* does not exist') {
                        Write-Log "User '$userUPN' not found in Graph." -Level INFO
                        $graphUserIdCache[$userUPN] = $null
                    } else {
                        $graphUserIdCache[$userUPN] = $null
                    }
                }
            }
        }
        $userOU = $null
        if ($userDN -match '(OU=|CN=Users|CN=Computers)') { $userOU = $userDN -replace '^CN=.*?,(OU=.*)$','$1' -replace '^CN=.*?,(CN=(Users|Computers).*)$','$1' }
        $user | Add-Member -MemberType NoteProperty -Name AD_OU -Value $userOU -Force -ErrorAction SilentlyContinue
        $managerSam = $null
        if ($user.manager) {
            try {
                $managerObj = Get-ADUser -Identity $user.manager -Properties SamAccountName -Server $DomainController -ErrorAction SilentlyContinue
                if ($managerObj) { $managerSam = $managerObj.SamAccountName }
            } catch {
                Write-Verbose "Could not resolve manager SAM for user '$userSam' (Manager DN: $($user.manager))"
            }
        }
        $user | Add-Member -MemberType NoteProperty -Name Manager_SamAccountName -Value $managerSam -Force -ErrorAction SilentlyContinue
        if ($oneDriveUsageHash -and $userUPN -and $oneDriveUsageHash.ContainsKey($userUPN)) {
            $oneDriveInfo = $oneDriveUsageHash[$userUPN][0]
            $user | Add-Member -MemberType NoteProperty -Name OneDrive_QuotaTotal -Value $oneDriveInfo.StorageAllocatedBytes -Force -ErrorAction SilentlyContinue
            $user | Add-Member -MemberType NoteProperty -Name OneDrive_QuotaUsed -Value $oneDriveInfo.StorageUsedBytes -Force -ErrorAction SilentlyContinue
            $user | Add-Member -MemberType NoteProperty -Name OneDrive_QuotaState -Value $oneDriveInfo.StorageRemainingBytes -Force -ErrorAction SilentlyContinue
            $user | Add-Member -MemberType NoteProperty -Name OneDrive_DriveId -Value $oneDriveInfo.DriveId -Force -ErrorAction SilentlyContinue
        } else {
            $user | Add-Member -MemberType NoteProperty -Name OneDrive_QuotaTotal -Value $null -Force -ErrorAction SilentlyContinue
            $user | Add-Member -MemberType NoteProperty -Name OneDrive_QuotaUsed -Value $null -Force -ErrorAction SilentlyContinue
            $user | Add-Member -MemberType NoteProperty -Name OneDrive_QuotaState -Value "NotFoundOrError" -Force -ErrorAction SilentlyContinue
            $user | Add-Member -MemberType NoteProperty -Name OneDrive_DriveId -Value $null -Force -ErrorAction SilentlyContinue
        }
        $user | Add-Member -MemberType NoteProperty -Name AzureADObjectId -Value $userGraphId -Force -ErrorAction SilentlyContinue
        $coreProps = $user.PSObject.Properties | Where-Object {$_.MemberType -in @('NoteProperty', 'AliasProperty', 'ScriptProperty')} | Select-Object -ExpandProperty Name
        $excludedProps = @('PropertyNames', 'PropertyCount', 'Count', 'Length', 'SyncRoot', 'IsReadOnly', 'IsFixedSize', 'IsSynchronized', 'Item', 'PSStandardMembers', 'PSAdapted', 'PSBase', 'PSTypeNames', 'PSObject')
        $propsToSelect = $coreProps | Where-Object {$_ -notin $excludedProps}
        $batchUsersCore.Add(($user | Select-Object -Property $propsToSelect))
        if ($userGroupMembershipsAD.ContainsKey($userSam)) {
            $userGroupMembershipsAD[$userSam] | ForEach-Object {
                $groupDN = $_
                $groupInfo = $secGroupData | Where-Object {$_.DistinguishedName -eq $groupDN}
                if ($groupInfo) {
                    $groupInfo = $groupInfo[0]
                    $batchUserSecGroupMembership.Add([PSCustomObject]@{
                        UserIdentifier      = $userId
                        GroupSamAccountName = $groupInfo.SamAccountName
                        GroupName           = $groupInfo.Name
                        GroupDN             = $groupDN
                        GroupCategory       = $groupInfo.GroupCategory
                        GroupScope          = $groupInfo.GroupScope
                    })
                }
            }
        }
        if ($dlData) {
            foreach ($dl in $dlData) {
                if ($dl.PSObject.Properties.Name -contains 'Members' -and $dl.Members) {
                    $memberString = $dl.Members.ToLower()
                    $isMember = $false
                    if ($userEmail -and $memberString -like "*$($userEmail.ToLower())*") { $isMember = $true }
                    elseif ($userUPN -and $memberString -like "*$($userUPN.ToLower())*") { $isMember = $true }
                    elseif ($userSam -and $memberString -like "*$($userSam.ToLower())*") { $isMember = $true }
                    if ($isMember) {
                        $batchUserDlMembership.Add([PSCustomObject]@{
                            UserIdentifier          = $userId
                            DL_PrimarySmtpAddress = $dl.PrimarySmtpAddress
                            DL_DisplayName        = $dl.DisplayName
                            DL_GroupType          = $dl.GroupType
                        })
                    }
                }
            }
        }
        if ($userToSharedMailboxPermsLookup) {
            $userKeys = @($userUPN, $userSam) | Where-Object { -not [string]::IsNullOrWhiteSpace($_) } | Select-Object -Unique
            foreach ($key in $userKeys) {
                if ($userToSharedMailboxPermsLookup.ContainsKey($key)) {
                    foreach ($perm in $userToSharedMailboxPermsLookup[$key]) {
                        if (-not ($batchUserSharedMbPerms | Where-Object {$_.UserIdentifier -eq $userId -and $_.SharedMailbox_PrimarySmtpAddress -eq $perm.SharedMailbox_PrimarySmtpAddress -and $_.PermissionType -eq $perm.PermissionType})) {
                            $batchUserSharedMbPerms.Add([PSCustomObject]@{
                                UserIdentifier                  = $userId
                                SharedMailbox_PrimarySmtpAddress = $perm.SharedMailbox_PrimarySmtpAddress
                                PermissionType                 = $perm.PermissionType
                                AccessRights                   = $perm.AccessRights
                                GrantedViaType                 = "DirectUserOrSAM"
                                GrantedViaIdentifier           = $perm.GrantedViaIdentifier
                            })
                        }
                    }
                }
            }
            if ($userGroupMembershipsAD.ContainsKey($userSam)) {
                $userADGroupsSAMs = $userGroupMembershipsAD[$userSam] | ForEach-Object {
                    $groupDN = $_
                    $groupInfo = $secGroupData | Where-Object {$_.DistinguishedName -eq $groupDN}
                    if ($groupInfo) { $groupInfo[0].SamAccountName } else { $null }
                } | Where-Object { $_ }
               }

               foreach ($groupSAM in $userADGroupsSAMs) {
    if ($userToSharedMailboxPermsLookup.ContainsKey($groupSAM)) {
        foreach ($perm in $userToSharedMailboxPermsLookup[$groupSAM]) {
            if (-not ($batchUserSharedMbPerms | Where-Object { $_.UserIdentifier -eq $userId -and $_.SharedMailbox_PrimarySmtpAddress -eq $perm.SharedMailbox_PrimarySmtpAddress -and $_.PermissionType -eq $perm.PermissionType })) {
                $batchUserSharedMbPerms.Add([PSCustomObject]@{
                    UserIdentifier                  = $userId
                    SharedMailbox_PrimarySmtpAddress = $perm.SharedMailbox_PrimarySmtpAddress
                    PermissionType                 = $perm.PermissionType
                    AccessRights                   = $perm.AccessRights
                    GrantedViaType                 = "ADGroup"
                    GrantedViaIdentifier           = $groupSAM
                })
            }
        }
    }
}

}
# Process GPOs
$appliedGPOs = Get-AppliedGPOsForUser -User $user -UserGroupMembershipSids $userGroupSidsAD -GpoPermissionsCache $gpoPermissionsCache -GpoLinkCache $gpoLinkCache
if ($appliedGPOs -and $appliedGPOs.Count -gt 0) {
    $batchUserAppliedGpos.AddRange([PSCustomObject[]]$appliedGPOs)
}

# Process Intune Policy Assignments
if (-not $script:GraphConnectionFailed -and $intunePolicyData -and $userGraphId) {
    foreach ($policy in $intunePolicyData) {
        if ($policy.Assignments) {
            $assignments = $policy.Assignments -split ';' | Where-Object { $_ }
            foreach ($assignment in $assignments) {
                $groupId = ($assignment -split ':')[0]
                if ($groupId -and ($assignment -like '*Include*')) {
                    $members = Get-GraphTransitiveGroupMembers -GroupId $groupId
                    if ($members -contains $userUPN) {
                        $batchUserIntuneAssignments.Add([PSCustomObject]@{
                            UserIdentifier = $userId
                            PolicyId       = $policy.PolicyId
                            PolicyName     = $policy.DisplayName
                            AssignmentType = "Group"
                            AssignedVia    = $groupId
                        })
                    }
                }
            }
        }
    }
}

# Process Enterprise Application Assignments
if (-not $script:GraphConnectionFailed -and $entAppData -and $userGraphId) {
    foreach ($app in $entAppData) {
        if ($app.Assignments) {
            $assignments = $app.Assignments -split ';' | Where-Object { $_ }
            foreach ($assignment in $assignments) {
                $parts = $assignment -split ':'
                $targetId = $parts[0]
                $assignmentType = $parts[1]
                if ($assignmentType -like '*Include*') {
                    if ($assignmentType -eq 'UserInclude' -and $targetId -eq $userGraphId) {
                        $batchUserAppAssignments.Add([PSCustomObject]@{
                            UserIdentifier = $userId
                            AppId          = $app.AppId
                            AppName        = $app.DisplayName
                            AssignmentType = "DirectUser"
                            AssignedVia    = $userGraphId
                        })
                    } elseif ($assignmentType -eq 'GroupInclude') {
                        $members = Get-GraphTransitiveGroupMembers -GroupId $targetId
                        if ($members -contains $userUPN) {
                            $batchUserAppAssignments.Add([PSCustomObject]@{
                                UserIdentifier = $userId
                                AppId          = $app.AppId
                                AppName        = $app.DisplayName
                                AssignmentType = "Group"
                                AssignedVia    = $targetId
                            })
                        }
                    }
                }
            }
        }
    }
}

# Process Logon Scripts, Drive Mappings, Folder Redirection, Printer Mappings
if ($logonScriptData -and $appliedGPOs) {
    $userGpoIds = $appliedGPOs | Select-Object -ExpandProperty GpoId -Unique
    foreach ($script in $logonScriptData) {
        if ($userGpoIds -contains $script.GpoId) {
            $batchUserLogonScripts.Add([PSCustomObject]@{
                UserIdentifier = $userId
                GpoId          = $script.GpoId
                ScriptPath     = $script.ScriptPath
                ScriptType     = $script.ScriptType
            })
        }
    }
}

if ($driveMapData -and $appliedGPOs) {
    $userGpoIds = $appliedGPOs | Select-Object -ExpandProperty GpoId -Unique
    foreach ($drive in $driveMapData) {
        if ($userGpoIds -contains $drive.GpoId) {
            $batchUserDriveMaps.Add([PSCustomObject]@{
                UserIdentifier = $userId
                GpoId          = $drive.GpoId
                DriveLetter    = $drive.DriveLetter
                UncPath        = $drive.UncPath
            })
        }
    }
}

if ($folderRedirData -and $appliedGPOs) {
    $userGpoIds = $appliedGPOs | Select-Object -ExpandProperty GpoId -Unique
    foreach ($redir in $folderRedirData) {
        if ($userGpoIds -contains $redir.GpoId) {
            $batchUserFolderRedir.Add([PSCustomObject]@{
                UserIdentifier = $userId
                GpoId          = $redir.GpoId
                FolderName     = $redir.FolderName
                RedirectedPath = $redir.RedirectedPath
            })
        }
    }
}

if ($printerMapData -and $appliedGPOs) {
    $userGpoIds = $appliedGPOs | Select-Object -ExpandProperty GpoId -Unique
    foreach ($printer in $printerMapData) {
        if ($userGpoIds -contains $printer.GpoId) {
            $batchUserPrinterMaps.Add([PSCustomObject]@{
                UserIdentifier = $userId
                GpoId          = $printer.GpoId
                PrinterName    = $printer.PrinterName
                PrinterPath    = $printer.PrinterPath
            })
        }
    }
}

# Process Teams Membership
if ($teamsData -and $userUPN) {
    $userTeams = $teamsData | Where-Object { $_.MemberUPN -eq $userUPN }
    foreach ($team in $userTeams) {
        $batchUserTeamMembership.Add([PSCustomObject]@{
            UserIdentifier = $userId
            TeamId         = $team.TeamId
            TeamName       = $team.TeamName
            Role           = $team.Role
        })
    }
}

# Process License Assignments
if ($licensingData -and $userUPN) {
    $userLicenses = $licensingData | Where-Object { $_.UserPrincipalName -eq $userUPN }
    foreach ($license in $userLicenses) {
        $batchUserLicenseAssignments.Add([PSCustomObject]@{
            UserIdentifier = $userId
            SkuId          = $license.SkuId
            SkuPartNumber  = $license.SkuPartNumber
            ServicePlans   = $license.ServicePlans
        })
    }
}

# Process Device Inventory
if ($deviceInventoryData -and $userUPN) {
    $userDevices = $deviceInventoryData | Where-Object { $_.RegisteredOwnerUPN -eq $userUPN }
    foreach ($device in $userDevices) {
        $batchUserDevices.Add([PSCustomObject]@{
            UserIdentifier = $userId
            DeviceId       = $device.DeviceId
            DeviceName     = $device.DeviceName
            DeviceType     = $device.DeviceType
            LastSeen       = $device.LastSeen
        })
    }
}

# Process Conditional Access Policy Assignments
if (-not $script:GraphConnectionFailed -and $caAssignmentData -and $userGraphId) {
    if ($caAssignmentLookup.ContainsKey($userGraphId)) {
        foreach ($assignment in $caAssignmentLookup[$userGraphId]) {
            $policyId = $assignment.PolicyId
            if ($caPolicyHash.ContainsKey($policyId)) {
                $policy = $caPolicyHash[$policyId][0]
                $batchUserCAPolicyAssignments.Add([PSCustomObject]@{
                    UserIdentifier = $userId
                    PolicyId       = $policyId
                    PolicyName     = $policy.DisplayName
                    AssignmentType = "DirectUser"
                    AssignedVia    = $userGraphId
                })
            }
        }
    }
    if ($userGroupMembershipsAD.ContainsKey($userSam)) {
        $userADGroups = $userGroupMembershipsAD[$userSam] | ForEach-Object {
            $groupDN = $_
            $groupInfo = $secGroupData | Where-Object { $_.DistinguishedName -eq $groupDN }
            if ($groupInfo) { $groupInfo[0] } else { $null }
        } | Where-Object { $_ }
        foreach ($group in $userADGroups) {
            if ($group.ObjectGuid -and $caAssignmentLookup.ContainsKey($group.ObjectGuid)) {
                foreach ($assignment in $caAssignmentLookup[$group.ObjectGuid]) {
                    $policyId = $assignment.PolicyId
                    if ($caPolicyHash.ContainsKey($policyId)) {
                        $policy = $caPolicyHash[$policyId][0]
                        $batchUserCAPolicyAssignments.Add([PSCustomObject]@{
                            UserIdentifier = $userId
                            PolicyId       = $policyId
                            PolicyName     = $policy.DisplayName
                            AssignmentType = "Group"
                            AssignedVia    = $group.ObjectGuid
                        })
                    }
                }
            }
        }
    }
}

$lastUserProcessedInBatch = $userId
if ($currentBatchUserCount -ge $BatchSize -or $processedUserCountTotal -eq $totalUserCount) {
    Write-Log "Writing batch of $currentBatchUserCount users to CSV files..." -Level INFO
    $batchData = @{
        "UsersCore"                   = $batchUsersCore
        "UserSecurityGroupMembership" = $batchUserSecGroupMembership
        "UserDlMembership"            = $batchUserDlMembership
        "UserSharedMailboxPermissions"= $batchUserSharedMbPerms
        "UserAppliedGPOs"             = $batchUserAppliedGpos
        "UserIntuneAssignments"       = $batchUserIntuneAssignments
        "UserAppAssignments"          = $batchUserAppAssignments
        "UserLogonScripts"            = $batchUserLogonScripts
        "UserDriveMappings"           = $batchUserDriveMaps
        "UserFolderRedirection"       = $batchUserFolderRedir
        "UserPrinterMappings"         = $batchUserPrinterMaps
        "UserTeamMembership"          = $batchUserTeamMembership
        "UserLicenseAssignments"      = $batchUserLicenseAssignments
        "UserDevices"                 = $batchUserDevices
        "UserCAPolicyAssignments"     = $batchUserCAPolicyAssignments
    }
    Append-BatchToCsvs -BatchData $batchData
    Write-Log "Saving state to $($script:StateFilePath) with last processed user: $lastUserProcessedInBatch" -Level INFO
    try {
        Set-Content -Path $script:StateFilePath -Value $lastUserProcessedInBatch -ErrorAction Stop
    } catch {
        Write-Log "Error saving state to '$($script:StateFilePath)': $($_.Exception.Message)" -Level ERROR
    }
    $batchUsersCore.Clear()
    $batchUserSecGroupMembership.Clear()
    $batchUserDlMembership.Clear()
    $batchUserSharedMbPerms.Clear()
    $batchUserAppliedGpos.Clear()
    $batchUserIntuneAssignments.Clear()
    $batchUserAppAssignments.Clear()
    $batchUserLogonScripts.Clear()
    $batchUserDriveMaps.Clear()
    $batchUserFolderRedir.Clear()
    $batchUserPrinterMaps.Clear()
    $batchUserTeamMembership.Clear()
    $batchUserLicenseAssignments.Clear()
    $batchUserDevices.Clear()
    $batchUserCAPolicyAssignments.Clear()
    $currentBatchUserCount = 0
    Write-Log "Batch processing completed. Cleared batch lists." -Level INFO
}
}

Write-Progress -Activity "Aggregating User Data" -Completed
Write-Log "Aggregation script completed all phases." -Level INFO
Write-Log "Total users processed: $processedUserCountTotal of $totalUserCount." -Level INFO
if ($script:GraphConnectionFailed) {
    Write-Log "Some data was skipped due to Graph connection issues." -Level WARN
}
if ($batchUserAppliedGpos.Count -gt 0) {
    Write-Log "Final GPO assignments recorded: $($batchUserAppliedGpos.Count)" -Level INFO
}
$userAppliedGposCsvPath = Join-Path $OutputCsvPath "UserAppliedGPOs.csv"
if (Test-Path $userAppliedGposCsvPath -PathType Leaf) {
    Write-Log "UserAppliedGPOs.csv was generated at: $userAppliedGposCsvPath" -Level INFO
} else {
    Write-Log "UserAppliedGPOs.csv was not generated. Check if GPO data exists or if processing was interrupted." -Level WARN
}
Write-Log "Script execution finished." -Level INFO

} finally {
    Write-Log "Executing cleanup in finally block..."
    try {
        Disconnect-MgGraph -ErrorAction SilentlyContinue
        Write-Log "Disconnected from Microsoft Graph." -Level INFO
    } catch {
        Write-Log "Error disconnecting from Graph: $($_.Exception.Message)" -Level WARN
    }
}



#endregion Main Aggregation Logic
